using System;
using L10n.Plural.Ast;

namespace L10n.Plural
{
	/// <summary>
	/// Represents a plural rule that will evaluate a given number 
	/// using an abstract syntax tree generated by a plural rule formula parser.
	/// </summary>
	public class AstPluralRule : IPluralRule
	{
		/// <summary>
		/// Maximum number of plural forms supported.
		/// </summary>
		public int NumPlurals { get; protected set; }

		protected Token AstRoot { get; set; }

		/// <summary>
		/// Initializes a new instance of the <see cref="Token"/> class with given NumPlurals and abstract syntax tree.
		/// </summary>
		/// <param name="numPlurals"></param>
		/// <param name="astRoot">Abstract syntax tree root.</param>
		public AstPluralRule(int numPlurals, Token astRoot)
		{
			if (numPlurals <= 0)
				throw new ArgumentOutOfRangeException("numPlurals");
			if (astRoot == null)
				throw new ArgumentNullException("astRoot");

			NumPlurals = numPlurals;
			AstRoot = astRoot;
		}

		/// <summary>
		/// Evaluates a number and returns a plural form index.
		/// </summary>
		/// <param name="number">Number which needs to be evaluated.</param>
		/// <returns>Plural form index.</returns>
		public int Evaluate(long number)
		{
			return (int)Evaluate(AstRoot, number);
		}

		protected long Evaluate(Token node, long number)
		{
			switch (node.Type)
			{
				case TokenType.Number:
					return node.Value;

				case TokenType.N:
					return number;

				case TokenType.Plus:
					return Evaluate(node.Children[0], number)
						 + Evaluate(node.Children[1], number);

				case TokenType.Minus:
					return Evaluate(node.Children[0], number)
						 - Evaluate(node.Children[1], number);

				case TokenType.Divide:
					return Evaluate(node.Children[0], number)
						 / Evaluate(node.Children[1], number);

				case TokenType.Multiply:
					return Evaluate(node.Children[0], number)
						 * Evaluate(node.Children[1], number);

				case TokenType.Modulo:
					return Evaluate(node.Children[0], number)
						 % Evaluate(node.Children[1], number);

				case TokenType.GreaterThan:
					return Evaluate(node.Children[0], number)
						 > Evaluate(node.Children[1], number)
						 ? 1 : 0;

				case TokenType.GreaterOrEquals:
					return Evaluate(node.Children[0], number)
						>= Evaluate(node.Children[1], number)
						 ? 1 : 0;

				case TokenType.LessThan:
					return Evaluate(node.Children[0], number)
						 < Evaluate(node.Children[1], number)
						 ? 1 : 0;

				case TokenType.LessOrEquals:
					return Evaluate(node.Children[0], number)
						<= Evaluate(node.Children[1], number)
						 ? 1 : 0;

				case TokenType.Equals:
					return Evaluate(node.Children[0], number)
						== Evaluate(node.Children[1], number)
						 ? 1 : 0;

				case TokenType.NotEquals:
					return Evaluate(node.Children[0], number)
						!= Evaluate(node.Children[1], number)
						 ? 1 : 0;

				case TokenType.And:
					return Evaluate(node.Children[0], number) != 0
						&& Evaluate(node.Children[1], number) != 0
						 ? 1 : 0;

				case TokenType.Or:
					return Evaluate(node.Children[0], number) != 0
						|| Evaluate(node.Children[1], number) != 0
						 ? 1 : 0;

				case TokenType.Not:
					return Evaluate(node.Children[0], number) == 0
						 ? 1 : 0;

				case TokenType.TernaryIf:
					return Evaluate(node.Children[0], number) != 0
						 ? Evaluate(node.Children[1], number)
						 : Evaluate(node.Children[2], number);

				default:
					throw new InvalidOperationException(String.Format("Can not evaluate token: {0}.", node.Type));
			}
		}
	}
}
