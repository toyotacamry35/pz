// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using SharedCode.Entities.Service;
using SharedCode.EntitySystem.ChainCalls;
using SharedCode.Logging;
using SharedCode.OurSimpleIoC;
using SharedCode.Utils;
using System.Linq;
using System.Collections.Generic;
using System.CodeDom.Compiler;

namespace GeneratedCode.DeltaObjects.Chain
{
    [GeneratedCode("CodeGen", "1.0")]
    public class CheatServiceAgentEntityChainProxy : BaseChainEntity
    {
        public CheatServiceAgentEntityChainProxy(SharedCode.Entities.Service.ICheatServiceAgentEntity entity): base(entity)
        {
        }

        public CheatServiceAgentEntityChainProxy(SharedCode.Entities.Service.ICheatServiceAgentEntity entity, IChainedEntity fromChain): base(entity, fromChain)
        {
        }

        public CheatServiceAgentEntityChainProxy GetRepositoryEntitiesCount()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 0, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceAgentEntityChainProxy DumpRepository()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 1, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceAgentEntityChainProxy ForceGC(ChainArgument<int> count)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (count is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)count).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)count);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 2, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceAgentEntityChainProxy SetGCEnabled(ChainArgument<bool> enabled)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (enabled is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)enabled).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enabled);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 3, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceAgentEntityChainProxy Delay(float duration, bool repeat = false, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, repeat ? -1 : 0, fromUtcNow));
            return this;
        }

        public CheatServiceAgentEntityChainProxy DelayCount(float duration, int count, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, count, fromUtcNow));
            return this;
        }

        public CheatServiceAgentEntityChainProxy StoreResult(string name)
        {
            ((ChainBlockCall)chainBatch.Chain.Last()).SetStoreResultKey(name);
            return this;
        }
    }

    public static partial class ChainProxyExtensions
    {
        public static CheatServiceAgentEntityChainProxy Chain(this SharedCode.Entities.Service.ICheatServiceAgentEntity entity)
        {
            return new CheatServiceAgentEntityChainProxy(entity);
        }

        public static CheatServiceAgentEntityChainProxy ContinueChain(this SharedCode.Entities.Service.ICheatServiceAgentEntity entity, IChainedEntity fromChain)
        {
            return new CheatServiceAgentEntityChainProxy(entity, fromChain);
        }
    }
}

namespace GeneratedCode.DeltaObjects.Chain
{
    [GeneratedCode("CodeGen", "1.0")]
    public class CheatServiceEntityChainProxy : BaseChainEntity
    {
        public CheatServiceEntityChainProxy(SharedCode.Entities.Service.ICheatServiceEntity entity): base(entity)
        {
        }

        public CheatServiceEntityChainProxy(SharedCode.Entities.Service.ICheatServiceEntity entity, IChainedEntity fromChain): base(entity, fromChain)
        {
        }

        public CheatServiceEntityChainProxy AddSomeItems(ChainArgument<System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack>> prototypeNames, ChainArgument<SharedCode.EntitySystem.PropertyAddress> source)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (prototypeNames is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)prototypeNames).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack>)prototypeNames);
                if (source is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 0, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy AddItemsInSlot(ChainArgument<SharedCode.Entities.ItemResourcePack> prototypeName, ChainArgument<SharedCode.EntitySystem.PropertyAddress> source, ChainArgument<int> slot)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (prototypeName is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)prototypeName).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.ItemResourcePack)prototypeName);
                if (source is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                if (slot is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)slot).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)slot);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 1, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy AddQuest(ChainArgument<Assets.Src.Aspects.Impl.Factions.Template.QuestDef> quest, ChainArgument<System.Guid> characterId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (quest is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)quest).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.Src.Aspects.Impl.Factions.Template.QuestDef)quest);
                if (characterId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)characterId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)characterId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 2, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy AddTechPoints(ChainArgument<SharedCode.Aspects.Science.TechPointCount[]> techPointCounts, ChainArgument<System.Guid> characterId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (techPointCounts is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)techPointCounts).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Science.TechPointCount[])techPointCounts);
                if (characterId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)characterId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)characterId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 3, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy AddKnowledge(ChainArgument<SharedCode.Aspects.Science.KnowledgeDef> knowledgeDef, ChainArgument<System.Guid> characterId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (knowledgeDef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)knowledgeDef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Science.KnowledgeDef)knowledgeDef);
                if (characterId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)characterId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)characterId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 4, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SpawnInteractiveObjectEntity(ChainArgument<SharedCode.Entities.GameObjectEntities.InteractiveEntityDef> entityDef, ChainArgument<SharedCode.Utils.Vector3> position)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entityDef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entityDef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.InteractiveEntityDef)entityDef);
                if (position is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)position).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)position);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 5, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SpawnNewMineableEntity(ChainArgument<SharedCode.Entities.GameObjectEntities.MineableEntityDef> entityDef, ChainArgument<SharedCode.Utils.Vector3> position)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entityDef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entityDef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.MineableEntityDef)entityDef);
                if (position is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)position).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)position);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 6, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SpawnInteractiveEntity(ChainArgument<SharedCode.Entities.GameObjectEntities.InteractiveEntityDef> entityDef, ChainArgument<SharedCode.Utils.Vector3> position)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entityDef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entityDef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.InteractiveEntityDef)entityDef);
                if (position is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)position).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)position);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 7, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy GetRepositoryEntitiesCount()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 8, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy GetRepositoryEntitiesCountOnAllRepositories()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 9, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy DumpAllServerRepositories()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 10, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetVisibilityRadius(ChainArgument<float> enterRadius, ChainArgument<float> leaveRadius)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (enterRadius is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)enterRadius).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)enterRadius);
                if (leaveRadius is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)leaveRadius).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)leaveRadius);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 11, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy GetTooLongEntityWaitQueues()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 12, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy GetCCU()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 13, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetDebugMode(ChainArgument<bool> enabled)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (enabled is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)enabled).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enabled);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 14, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetDebugMobs(ChainArgument<bool> enabledStatus, ChainArgument<bool> hard)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (enabledStatus is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)enabledStatus).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enabledStatus);
                if (hard is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)hard).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)hard);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 15, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetDebugSpells(ChainArgument<bool> enabledStatus)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (enabledStatus is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)enabledStatus).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enabledStatus);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 16, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy PrintBrokenLocomotions()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 17, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy DamageAllItems(ChainArgument<System.Guid> character, ChainArgument<float> percent)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (character is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)character).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)character);
                if (percent is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)percent).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)percent);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 18, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetDebugMobPositionLogging(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> outerRef, ChainArgument<bool> enabledStatus, ChainArgument<bool> dump)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (outerRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)outerRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)outerRef);
                if (enabledStatus is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)enabledStatus).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enabledStatus);
                if (dump is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)dump).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)dump);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 19, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetCurveLoggerState(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> charRef, ChainArgument<bool> enabledStatus, ChainArgument<bool> dump, ChainArgument<bool> serverOnly, ChainArgument<string> loggerName, ChainArgument<System.Guid> dumpId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (charRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)charRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)charRef);
                if (enabledStatus is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)enabledStatus).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enabledStatus);
                if (dump is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)dump).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)dump);
                if (serverOnly is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)serverOnly).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)serverOnly);
                if (loggerName is IChainResult)
                    argumetRefs.Add(4, ((IChainResult)loggerName).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)loggerName);
                if (dumpId is IChainResult)
                    argumetRefs.Add(5, ((IChainResult)dumpId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)dumpId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 20, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetLoggableEnable(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> outerRef, ChainArgument<bool> enabledStatus)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (outerRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)outerRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)outerRef);
                if (enabledStatus is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)enabledStatus).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enabledStatus);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 21, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy MainUnityThreadOnServerSleep(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> charRef, ChainArgument<bool> isOn, ChainArgument<float> sleepTime, ChainArgument<float> delayBeforeSleep, ChainArgument<float> repeatTime)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (charRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)charRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)charRef);
                if (isOn is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)isOn).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)isOn);
                if (sleepTime is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)sleepTime).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)sleepTime);
                if (delayBeforeSleep is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)delayBeforeSleep).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)delayBeforeSleep);
                if (repeatTime is IChainResult)
                    argumetRefs.Add(4, ((IChainResult)repeatTime).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)repeatTime);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 22, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy ChangeHealth(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> victimEntity, ChainArgument<int> deltaValue)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (victimEntity is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)victimEntity).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)victimEntity);
                if (deltaValue is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)deltaValue).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)deltaValue);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 23, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy Godmode(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> applicantEntityRef, ChainArgument<bool> enable)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (applicantEntityRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)applicantEntityRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)applicantEntityRef);
                if (enable is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)enable).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enable);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 24, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy Version01()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 25, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy ResolveCharacterCoords(ChainArgument<System.Guid[]> guids)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (guids is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)guids).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid[])guids);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 26, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy ForceGC(ChainArgument<int> count, ChainArgument<System.Guid> repositoryId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (count is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)count).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)count);
                if (repositoryId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)repositoryId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)repositoryId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 27, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy ForceSelfCompactionGC()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 28, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetGCEnabled(ChainArgument<bool> enabled, ChainArgument<System.Guid> repositoryId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (enabled is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)enabled).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enabled);
                if (repositoryId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)repositoryId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)repositoryId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 29, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy CastSpell(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> entityRef, ChainArgument<SharedCode.Wizardry.SpellCast> spellCast)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entityRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entityRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)entityRef);
                if (spellCast is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)spellCast).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Wizardry.SpellCast)spellCast);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 30, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetServerCheatVariable(ChainArgument<Assets.Src.ResourcesSystem.Base.BaseResource> resource, ChainArgument<string> value)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (resource is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)resource).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.Src.ResourcesSystem.Base.BaseResource)resource);
                if (value is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)value).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)value);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 31, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy TestCheckPZ15200Done(ChainArgument<float> waitBeforeReplicate)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (waitBeforeReplicate is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)waitBeforeReplicate).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)waitBeforeReplicate);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 32, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy EnableWizardLogger(ChainArgument<ResourceSystem.Utils.OuterRef> entity, ChainArgument<bool> enable)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entity is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entity).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (ResourceSystem.Utils.OuterRef)entity);
                if (enable is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)enable).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enable);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 33, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy SetGender(ChainArgument<ResourceSystem.Utils.OuterRef> entity, ChainArgument<ResourceSystem.Aspects.Misc.GenderDef> gender)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entity is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entity).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (ResourceSystem.Utils.OuterRef)entity);
                if (gender is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)gender).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (ResourceSystem.Aspects.Misc.GenderDef)gender);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 34, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy InvokeTrauma(ChainArgument<ResourceSystem.Utils.OuterRef> entity, ChainArgument<string> trauma)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entity is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entity).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (ResourceSystem.Utils.OuterRef)entity);
                if (trauma is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)trauma).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)trauma);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 35, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy StopTrauma(ChainArgument<ResourceSystem.Utils.OuterRef> entity, ChainArgument<string> trauma)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entity is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entity).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (ResourceSystem.Utils.OuterRef)entity);
                if (trauma is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)trauma).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)trauma);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 36, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CheatServiceEntityChainProxy Delay(float duration, bool repeat = false, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, repeat ? -1 : 0, fromUtcNow));
            return this;
        }

        public CheatServiceEntityChainProxy DelayCount(float duration, int count, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, count, fromUtcNow));
            return this;
        }

        public CheatServiceEntityChainProxy StoreResult(string name)
        {
            ((ChainBlockCall)chainBatch.Chain.Last()).SetStoreResultKey(name);
            return this;
        }
    }

    public static partial class ChainProxyExtensions
    {
        public static CheatServiceEntityChainProxy Chain(this SharedCode.Entities.Service.ICheatServiceEntity entity)
        {
            return new CheatServiceEntityChainProxy(entity);
        }

        public static CheatServiceEntityChainProxy ContinueChain(this SharedCode.Entities.Service.ICheatServiceEntity entity, IChainedEntity fromChain)
        {
            return new CheatServiceEntityChainProxy(entity, fromChain);
        }
    }
}