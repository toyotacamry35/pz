// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using SharedCode.Entities.Service;
using SharedCode.EntitySystem.ChainCalls;
using SharedCode.Logging;
using SharedCode.OurSimpleIoC;
using SharedCode.Utils;
using System.Linq;
using System.Collections.Generic;
using System.CodeDom.Compiler;

namespace GeneratedCode.DeltaObjects.Chain
{
    [GeneratedCode("CodeGen", "1.0")]
    public class WorldNodeServiceEntityChainProxy : BaseChainEntity
    {
        public WorldNodeServiceEntityChainProxy(SharedCode.Entities.Service.IWorldNodeServiceEntity entity): base(entity)
        {
        }

        public WorldNodeServiceEntityChainProxy(SharedCode.Entities.Service.IWorldNodeServiceEntity entity, IChainedEntity fromChain): base(entity, fromChain)
        {
        }

        public WorldNodeServiceEntityChainProxy IsReady()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 0, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldNodeServiceEntityChainProxy HostUnityMapChunk(ChainArgument<GeneratedCode.Custom.Config.MapDef> mapChunk)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (mapChunk is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)mapChunk).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (GeneratedCode.Custom.Config.MapDef)mapChunk);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 1, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldNodeServiceEntityChainProxy HostUnityMapChunk(ChainArgument<GeneratedCode.Custom.Config.MapDef> mapChunk, ChainArgument<System.Guid> mapChunkId, ChainArgument<System.Guid> mapInstanceId, ChainArgument<System.Guid> mapInstanceRepositoryId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (mapChunk is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)mapChunk).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (GeneratedCode.Custom.Config.MapDef)mapChunk);
                if (mapChunkId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)mapChunkId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)mapChunkId);
                if (mapInstanceId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)mapInstanceId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)mapInstanceId);
                if (mapInstanceRepositoryId is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)mapInstanceRepositoryId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)mapInstanceRepositoryId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 2, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldNodeServiceEntityChainProxy HostedUnityMapChunk(ChainArgument<GeneratedCode.Custom.Config.MapDef> mapChunk, ChainArgument<System.Guid> mapChunkId, ChainArgument<System.Guid> mapInstanceId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (mapChunk is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)mapChunk).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (GeneratedCode.Custom.Config.MapDef)mapChunk);
                if (mapChunkId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)mapChunkId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)mapChunkId);
                if (mapInstanceId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)mapInstanceId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)mapInstanceId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 3, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldNodeServiceEntityChainProxy SetState(ChainArgument<SharedCode.Entities.Service.WorldNodeServiceState> state)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (state is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)state).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.Service.WorldNodeServiceState)state);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 4, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldNodeServiceEntityChainProxy InitializePorts()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 5, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldNodeServiceEntityChainProxy CanBuildHere(ChainArgument<SharedCode.Entities.GameObjectEntities.IEntityObjectDef> entityObjectDef, ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> ent, ChainArgument<SharedCode.Utils.Vector3> position, ChainArgument<SharedCode.Utils.Vector3> scale, ChainArgument<SharedCode.Utils.Quaternion> rotation)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entityObjectDef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entityObjectDef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.IEntityObjectDef)entityObjectDef);
                if (ent is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)ent).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)ent);
                if (position is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)position).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)position);
                if (scale is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)scale).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)scale);
                if (rotation is IChainResult)
                    argumetRefs.Add(4, ((IChainResult)rotation).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Quaternion)rotation);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 6, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldNodeServiceEntityChainProxy GetDropPosition(ChainArgument<SharedCode.Utils.Vector3> playerPosition, ChainArgument<SharedCode.Utils.Quaternion> playerRotation)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (playerPosition is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)playerPosition).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)playerPosition);
                if (playerRotation is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)playerRotation).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Quaternion)playerRotation);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 7, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldNodeServiceEntityChainProxy Delay(float duration, bool repeat = false, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, repeat ? -1 : 0, fromUtcNow));
            return this;
        }

        public WorldNodeServiceEntityChainProxy DelayCount(float duration, int count, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, count, fromUtcNow));
            return this;
        }

        public WorldNodeServiceEntityChainProxy StoreResult(string name)
        {
            ((ChainBlockCall)chainBatch.Chain.Last()).SetStoreResultKey(name);
            return this;
        }
    }

    public static partial class ChainProxyExtensions
    {
        public static WorldNodeServiceEntityChainProxy Chain(this SharedCode.Entities.Service.IWorldNodeServiceEntity entity)
        {
            return new WorldNodeServiceEntityChainProxy(entity);
        }

        public static WorldNodeServiceEntityChainProxy ContinueChain(this SharedCode.Entities.Service.IWorldNodeServiceEntity entity, IChainedEntity fromChain)
        {
            return new WorldNodeServiceEntityChainProxy(entity, fromChain);
        }
    }
}