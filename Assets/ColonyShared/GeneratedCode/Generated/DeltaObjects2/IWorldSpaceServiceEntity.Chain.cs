// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using SharedCode.Entities.Service;
using SharedCode.EntitySystem.ChainCalls;
using SharedCode.Logging;
using SharedCode.OurSimpleIoC;
using SharedCode.Utils;
using System.Linq;
using System.Collections.Generic;
using System.CodeDom.Compiler;

namespace GeneratedCode.DeltaObjects.Chain
{
    [GeneratedCode("CodeGen", "1.0")]
    public class WorldSpaceServiceEntityChainProxy : BaseChainEntity
    {
        public WorldSpaceServiceEntityChainProxy(SharedCode.Entities.Service.IWorldSpaceServiceEntity entity): base(entity)
        {
        }

        public WorldSpaceServiceEntityChainProxy(SharedCode.Entities.Service.IWorldSpaceServiceEntity entity, IChainedEntity fromChain): base(entity, fromChain)
        {
        }

        public WorldSpaceServiceEntityChainProxy GetWorldNodeId(ChainArgument<ResourceSystem.Utils.OuterRef> entityRef)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (entityRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)entityRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (ResourceSystem.Utils.OuterRef)entityRef);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 0, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy AddWorldObject(ChainArgument<int> typeId, ChainArgument<System.Guid> entityId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (typeId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)typeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)typeId);
                if (entityId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)entityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)entityId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 1, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy RemoveWorldObject(ChainArgument<int> typeId, ChainArgument<System.Guid> entityId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (typeId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)typeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)typeId);
                if (entityId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)entityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)entityId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 2, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy UpdateTransform(ChainArgument<int> typeId, ChainArgument<System.Guid> entityId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (typeId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)typeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)typeId);
                if (entityId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)entityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)entityId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 3, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy AddClient(ChainArgument<System.Guid> characterId, ChainArgument<System.Guid> repositoryId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (characterId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)characterId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)characterId);
                if (repositoryId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)repositoryId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)repositoryId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 4, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy RemoveClient(ChainArgument<System.Guid> repositoryId, ChainArgument<bool> immediate)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (repositoryId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)repositoryId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)repositoryId);
                if (immediate is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)immediate).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)immediate);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 5, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy GetWorldBoxIdToDrop(ChainArgument<SharedCode.Utils.Vector3> position, ChainArgument<System.Guid> characterOwnerId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (position is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)position).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)position);
                if (characterOwnerId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)characterOwnerId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)characterOwnerId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 6, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy RegisterFencePlace(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.Entities.Building.IFencePlace>> fencePlace)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (fencePlace is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)fencePlace).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.Entities.Building.IFencePlace>)fencePlace);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 7, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy UnregisterFencePlace(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.Entities.Building.IFencePlace>> fencePlace)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (fencePlace is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)fencePlace).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.Entities.Building.IFencePlace>)fencePlace);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 8, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy CreateFencePlaceId(ChainArgument<SharedCode.Utils.Vector3> position)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (position is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)position).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)position);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 9, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy GetFencePlaceId(ChainArgument<SharedCode.Utils.Vector3> position, ChainArgument<bool> onlyExisted)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (position is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)position).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)position);
                if (onlyExisted is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)onlyExisted).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)onlyExisted);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 10, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy OnVisibilityChanged(ChainArgument<int> subjectTypeId, ChainArgument<System.Guid> subjectEntityId, ChainArgument<System.Collections.Generic.List<(int, System.Guid)>> addedObjects, ChainArgument<System.Collections.Generic.List<(int, System.Guid)>> removedObjects)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (subjectTypeId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)subjectTypeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)subjectTypeId);
                if (subjectEntityId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)subjectEntityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)subjectEntityId);
                if (addedObjects is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)addedObjects).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Collections.Generic.List<(int, System.Guid)>)addedObjects);
                if (removedObjects is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)removedObjects).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Collections.Generic.List<(int, System.Guid)>)removedObjects);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 11, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy EnableReplications(ChainArgument<int> subjectTypeId, ChainArgument<System.Guid> subjectEntityId, ChainArgument<bool> enable)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (subjectTypeId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)subjectTypeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)subjectTypeId);
                if (subjectEntityId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)subjectEntityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)subjectEntityId);
                if (enable is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)enable).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)enable);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 12, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy GetCCU()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 13, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy SpawnNewBot(ChainArgument<string> spawnPointTypePath, ChainArgument<System.Collections.Generic.List<System.Guid>> botIds, ChainArgument<System.Guid> userId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (spawnPointTypePath is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)spawnPointTypePath).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)spawnPointTypePath);
                if (botIds is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)botIds).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Collections.Generic.List<System.Guid>)botIds);
                if (userId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)userId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)userId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 14, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy Respawn(ChainArgument<System.Guid> charId, ChainArgument<bool> checkBakens, ChainArgument<bool> anyCommonBaken, ChainArgument<System.Guid> commonBakenId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (charId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)charId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)charId);
                if (checkBakens is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)checkBakens).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)checkBakens);
                if (anyCommonBaken is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)anyCommonBaken).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)anyCommonBaken);
                if (commonBakenId is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)commonBakenId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)commonBakenId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 15, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy Login(ChainArgument<Assets.Src.Aspects.Doings.BotActionDef> botDef, ChainArgument<string> spawnPointPath, ChainArgument<System.Guid> userRepository, ChainArgument<GeneratedCode.MapSystem.MapOwner> mapOwner)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (botDef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)botDef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.Src.Aspects.Doings.BotActionDef)botDef);
                if (spawnPointPath is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)spawnPointPath).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)spawnPointPath);
                if (userRepository is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)userRepository).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)userRepository);
                if (mapOwner is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)mapOwner).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (GeneratedCode.MapSystem.MapOwner)mapOwner);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 16, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy Logout(ChainArgument<System.Guid> userId, ChainArgument<bool> terminal)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (userId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)userId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)userId);
                if (terminal is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)terminal).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)terminal);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 17, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy LogoutAll()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 18, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy ConnectStreamingRepo(ChainArgument<System.Guid> repo)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (repo is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)repo).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)repo);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 19, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy DisconnectStreamingRepo(ChainArgument<System.Guid> repo)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (repo is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)repo).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)repo);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 20, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy Teleport(ChainArgument<System.Guid> oldRepositoryGuid)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (oldRepositoryGuid is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)oldRepositoryGuid).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)oldRepositoryGuid);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 21, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy PrepareStaticsFor(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> sceneEntity)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (sceneEntity is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)sceneEntity).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)sceneEntity);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 22, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy SpawnEntity(ChainArgument<System.Guid> staticIdFromExport, ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> ent, ChainArgument<SharedCode.Utils.Vector3> pos, ChainArgument<SharedCode.Utils.Quaternion> rot, ChainArgument<GeneratedCode.MapSystem.MapOwner> mapOwner, ChainArgument<System.Guid> spawner, ChainArgument<SharedCode.Entities.GameObjectEntities.IEntityObjectDef> def, ChainArgument<SharedCode.Entities.GameObjectEntities.SpawnPointTypeDef> point, ChainArgument<SharedCode.Entities.GameObjectEntities.ScenicEntityDef> scenicEntityDef, ChainArgument<Scripting.ScriptingContext> ctx)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (staticIdFromExport is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)staticIdFromExport).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)staticIdFromExport);
                if (ent is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)ent).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)ent);
                if (pos is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)pos).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Vector3)pos);
                if (rot is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)rot).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Utils.Quaternion)rot);
                if (mapOwner is IChainResult)
                    argumetRefs.Add(4, ((IChainResult)mapOwner).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (GeneratedCode.MapSystem.MapOwner)mapOwner);
                if (spawner is IChainResult)
                    argumetRefs.Add(5, ((IChainResult)spawner).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)spawner);
                if (def is IChainResult)
                    argumetRefs.Add(6, ((IChainResult)def).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.IEntityObjectDef)def);
                if (point is IChainResult)
                    argumetRefs.Add(7, ((IChainResult)point).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.SpawnPointTypeDef)point);
                if (scenicEntityDef is IChainResult)
                    argumetRefs.Add(8, ((IChainResult)scenicEntityDef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.ScenicEntityDef)scenicEntityDef);
                if (ctx is IChainResult)
                    argumetRefs.Add(9, ((IChainResult)ctx).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Scripting.ScriptingContext)ctx);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 23, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy DespawnEntity(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> ent)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (ent is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)ent).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)ent);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 24, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy GetPositionToSpawnAt(ChainArgument<System.Guid> charId, ChainArgument<bool> checkBakens, ChainArgument<bool> anyCommonBaken, ChainArgument<System.Guid> commonBakenId, ChainArgument<SharedCode.Entities.GameObjectEntities.SpawnPointTypeDef> overrideAllowedPointType)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (charId is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)charId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)charId);
                if (checkBakens is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)checkBakens).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)checkBakens);
                if (anyCommonBaken is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)anyCommonBaken).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)anyCommonBaken);
                if (commonBakenId is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)commonBakenId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)commonBakenId);
                if (overrideAllowedPointType is IChainResult)
                    argumetRefs.Add(4, ((IChainResult)overrideAllowedPointType).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.SpawnPointTypeDef)overrideAllowedPointType);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 25, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy RegisterWorldObjectsInNewInformationSet(ChainArgument<ResourceSystem.Utils.OuterRef> worldObjectSetRef)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (worldObjectSetRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)worldObjectSetRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (ResourceSystem.Utils.OuterRef)worldObjectSetRef);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 26, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldSpaceServiceEntityChainProxy Delay(float duration, bool repeat = false, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, repeat ? -1 : 0, fromUtcNow));
            return this;
        }

        public WorldSpaceServiceEntityChainProxy DelayCount(float duration, int count, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, count, fromUtcNow));
            return this;
        }

        public WorldSpaceServiceEntityChainProxy StoreResult(string name)
        {
            ((ChainBlockCall)chainBatch.Chain.Last()).SetStoreResultKey(name);
            return this;
        }
    }

    public static partial class ChainProxyExtensions
    {
        public static WorldSpaceServiceEntityChainProxy Chain(this SharedCode.Entities.Service.IWorldSpaceServiceEntity entity)
        {
            return new WorldSpaceServiceEntityChainProxy(entity);
        }

        public static WorldSpaceServiceEntityChainProxy ContinueChain(this SharedCode.Entities.Service.IWorldSpaceServiceEntity entity, IChainedEntity fromChain)
        {
            return new WorldSpaceServiceEntityChainProxy(entity, fromChain);
        }
    }
}