// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using System.Threading;
using System.Threading.Tasks;
using GeneratedCode.EntitySystem;
using SharedCode.Logging;
using System.Linq;
using SharedCode.EntitySystem;
using SharedCode.Network;

namespace GeneratedCode.DeltaObjects
{
    public partial class CheatServiceAgentEntity
    {
        public Task<string> GetRepositoryEntitiesCount()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return GetRepositoryEntitiesCountRunMaster().AsTask();
                else
                    return GetRepositoryEntitiesCountRun().AsTask();
            else
                return SendFuncs.GetRepositoryEntitiesCount(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<string>> GetRepositoryEntitiesCountCreateDeferredDelegate() => () =>
        {
            return GetRepositoryEntitiesCount();
        }

        ;
        public async ValueTask<string> GetRepositoryEntitiesCountRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(GetRepositoryEntitiesCountCreateDeferredDelegate(), nameof(GetRepositoryEntitiesCount));
            }

            return await GetRepositoryEntitiesCountRun();
        }

        public async ValueTask<string> GetRepositoryEntitiesCountRun()
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceAgentEntity), 0);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = GetRepositoryEntitiesCountImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task DumpRepository()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return DumpRepositoryRunMaster().AsTask();
                else
                    return DumpRepositoryRun().AsTask();
            else
                return SendFuncs.DumpRepository(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> DumpRepositoryCreateDeferredDelegate() => () =>
        {
            return DumpRepository();
        }

        ;
        public async ValueTask DumpRepositoryRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(DumpRepositoryCreateDeferredDelegate(), nameof(DumpRepository));
            }

            await DumpRepositoryRun();
        }

        public async ValueTask DumpRepositoryRun()
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceAgentEntity), 1);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = DumpRepositoryImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task ForceGC(int count)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return ForceGCRunMaster(count).AsTask();
                else
                    return ForceGCRun(count).AsTask();
            else
                return SendFuncs.ForceGC(count, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> ForceGCCreateDeferredDelegate(int count) => () =>
        {
            return ForceGC(count);
        }

        ;
        public async ValueTask ForceGCRunMaster(int count)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(ForceGCCreateDeferredDelegate(count), nameof(ForceGC));
            }

            await ForceGCRun(count);
        }

        public async ValueTask ForceGCRun(int count)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceAgentEntity), 2);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = ForceGCImpl(count);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetGCEnabled(bool enabled)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetGCEnabledRunMaster(enabled).AsTask();
                else
                    return SetGCEnabledRun(enabled).AsTask();
            else
                return SendFuncs.SetGCEnabled(enabled, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetGCEnabledCreateDeferredDelegate(bool enabled) => () =>
        {
            return SetGCEnabled(enabled);
        }

        ;
        public async ValueTask SetGCEnabledRunMaster(bool enabled)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetGCEnabledCreateDeferredDelegate(enabled), nameof(SetGCEnabled));
            }

            await SetGCEnabledRun(enabled);
        }

        public async ValueTask SetGCEnabledRun(bool enabled)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceAgentEntity), 3);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetGCEnabledImpl(enabled);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }
    }
}

namespace GeneratedCode.DeltaObjects
{
    public partial class CheatServiceEntity
    {
        public Task AddSomeItems(System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack> prototypeNames, SharedCode.EntitySystem.PropertyAddress source)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return AddSomeItemsRunMaster(prototypeNames, source).AsTask();
                else
                    return AddSomeItemsRun(prototypeNames, source).AsTask();
            else
                return SendFuncs.AddSomeItems(prototypeNames, source, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> AddSomeItemsCreateDeferredDelegate(System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack> prototypeNames, SharedCode.EntitySystem.PropertyAddress source) => () =>
        {
            return AddSomeItems(prototypeNames, source);
        }

        ;
        public async ValueTask AddSomeItemsRunMaster(System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack> prototypeNames, SharedCode.EntitySystem.PropertyAddress source)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(AddSomeItemsCreateDeferredDelegate(prototypeNames, source), nameof(AddSomeItems));
            }

            await AddSomeItemsRun(prototypeNames, source);
        }

        public async ValueTask AddSomeItemsRun(System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack> prototypeNames, SharedCode.EntitySystem.PropertyAddress source)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(AddSomeItems)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 0);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = AddSomeItemsImpl(prototypeNames, source);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task AddItemsInSlot(SharedCode.Entities.ItemResourcePack prototypeName, SharedCode.EntitySystem.PropertyAddress source, int slot)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return AddItemsInSlotRunMaster(prototypeName, source, slot).AsTask();
                else
                    return AddItemsInSlotRun(prototypeName, source, slot).AsTask();
            else
                return SendFuncs.AddItemsInSlot(prototypeName, source, slot, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> AddItemsInSlotCreateDeferredDelegate(SharedCode.Entities.ItemResourcePack prototypeName, SharedCode.EntitySystem.PropertyAddress source, int slot) => () =>
        {
            return AddItemsInSlot(prototypeName, source, slot);
        }

        ;
        public async ValueTask AddItemsInSlotRunMaster(SharedCode.Entities.ItemResourcePack prototypeName, SharedCode.EntitySystem.PropertyAddress source, int slot)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(AddItemsInSlotCreateDeferredDelegate(prototypeName, source, slot), nameof(AddItemsInSlot));
            }

            await AddItemsInSlotRun(prototypeName, source, slot);
        }

        public async ValueTask AddItemsInSlotRun(SharedCode.Entities.ItemResourcePack prototypeName, SharedCode.EntitySystem.PropertyAddress source, int slot)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(AddItemsInSlot)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 1);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = AddItemsInSlotImpl(prototypeName, source, slot);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task AddQuest(Assets.Src.Aspects.Impl.Factions.Template.QuestDef quest, System.Guid characterId)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return AddQuestRunMaster(quest, characterId).AsTask();
                else
                    return AddQuestRun(quest, characterId).AsTask();
            else
                return SendFuncs.AddQuest(quest, characterId, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> AddQuestCreateDeferredDelegate(Assets.Src.Aspects.Impl.Factions.Template.QuestDef quest, System.Guid characterId) => () =>
        {
            return AddQuest(quest, characterId);
        }

        ;
        public async ValueTask AddQuestRunMaster(Assets.Src.Aspects.Impl.Factions.Template.QuestDef quest, System.Guid characterId)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(AddQuestCreateDeferredDelegate(quest, characterId), nameof(AddQuest));
            }

            await AddQuestRun(quest, characterId);
        }

        public async ValueTask AddQuestRun(Assets.Src.Aspects.Impl.Factions.Template.QuestDef quest, System.Guid characterId)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(AddQuest)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 2);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = AddQuestImpl(quest, characterId);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task AddTechPoints(SharedCode.Aspects.Science.TechPointCount[] techPointCounts, System.Guid characterId)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return AddTechPointsRunMaster(techPointCounts, characterId).AsTask();
                else
                    return AddTechPointsRun(techPointCounts, characterId).AsTask();
            else
                return SendFuncs.AddTechPoints(techPointCounts, characterId, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> AddTechPointsCreateDeferredDelegate(SharedCode.Aspects.Science.TechPointCount[] techPointCounts, System.Guid characterId) => () =>
        {
            return AddTechPoints(techPointCounts, characterId);
        }

        ;
        public async ValueTask AddTechPointsRunMaster(SharedCode.Aspects.Science.TechPointCount[] techPointCounts, System.Guid characterId)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(AddTechPointsCreateDeferredDelegate(techPointCounts, characterId), nameof(AddTechPoints));
            }

            await AddTechPointsRun(techPointCounts, characterId);
        }

        public async ValueTask AddTechPointsRun(SharedCode.Aspects.Science.TechPointCount[] techPointCounts, System.Guid characterId)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(AddTechPoints)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 3);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = AddTechPointsImpl(techPointCounts, characterId);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task AddKnowledge(SharedCode.Aspects.Science.KnowledgeDef knowledgeDef, System.Guid characterId)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return AddKnowledgeRunMaster(knowledgeDef, characterId).AsTask();
                else
                    return AddKnowledgeRun(knowledgeDef, characterId).AsTask();
            else
                return SendFuncs.AddKnowledge(knowledgeDef, characterId, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> AddKnowledgeCreateDeferredDelegate(SharedCode.Aspects.Science.KnowledgeDef knowledgeDef, System.Guid characterId) => () =>
        {
            return AddKnowledge(knowledgeDef, characterId);
        }

        ;
        public async ValueTask AddKnowledgeRunMaster(SharedCode.Aspects.Science.KnowledgeDef knowledgeDef, System.Guid characterId)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(AddKnowledgeCreateDeferredDelegate(knowledgeDef, characterId), nameof(AddKnowledge));
            }

            await AddKnowledgeRun(knowledgeDef, characterId);
        }

        public async ValueTask AddKnowledgeRun(SharedCode.Aspects.Science.KnowledgeDef knowledgeDef, System.Guid characterId)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(AddKnowledge)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 4);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = AddKnowledgeImpl(knowledgeDef, characterId);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SpawnInteractiveObjectEntity(SharedCode.Entities.GameObjectEntities.InteractiveEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SpawnInteractiveObjectEntityRunMaster(entityDef, position).AsTask();
                else
                    return SpawnInteractiveObjectEntityRun(entityDef, position).AsTask();
            else
                return SendFuncs.SpawnInteractiveObjectEntity(entityDef, position, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SpawnInteractiveObjectEntityCreateDeferredDelegate(SharedCode.Entities.GameObjectEntities.InteractiveEntityDef entityDef, SharedCode.Utils.Vector3 position) => () =>
        {
            return SpawnInteractiveObjectEntity(entityDef, position);
        }

        ;
        public async ValueTask SpawnInteractiveObjectEntityRunMaster(SharedCode.Entities.GameObjectEntities.InteractiveEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SpawnInteractiveObjectEntityCreateDeferredDelegate(entityDef, position), nameof(SpawnInteractiveObjectEntity));
            }

            await SpawnInteractiveObjectEntityRun(entityDef, position);
        }

        public async ValueTask SpawnInteractiveObjectEntityRun(SharedCode.Entities.GameObjectEntities.InteractiveEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SpawnInteractiveObjectEntity)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 5);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SpawnInteractiveObjectEntityImpl(entityDef, position);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SpawnNewMineableEntity(SharedCode.Entities.GameObjectEntities.MineableEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SpawnNewMineableEntityRunMaster(entityDef, position).AsTask();
                else
                    return SpawnNewMineableEntityRun(entityDef, position).AsTask();
            else
                return SendFuncs.SpawnNewMineableEntity(entityDef, position, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SpawnNewMineableEntityCreateDeferredDelegate(SharedCode.Entities.GameObjectEntities.MineableEntityDef entityDef, SharedCode.Utils.Vector3 position) => () =>
        {
            return SpawnNewMineableEntity(entityDef, position);
        }

        ;
        public async ValueTask SpawnNewMineableEntityRunMaster(SharedCode.Entities.GameObjectEntities.MineableEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SpawnNewMineableEntityCreateDeferredDelegate(entityDef, position), nameof(SpawnNewMineableEntity));
            }

            await SpawnNewMineableEntityRun(entityDef, position);
        }

        public async ValueTask SpawnNewMineableEntityRun(SharedCode.Entities.GameObjectEntities.MineableEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SpawnNewMineableEntity)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 6);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SpawnNewMineableEntityImpl(entityDef, position);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SpawnInteractiveEntity(SharedCode.Entities.GameObjectEntities.InteractiveEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SpawnInteractiveEntityRunMaster(entityDef, position).AsTask();
                else
                    return SpawnInteractiveEntityRun(entityDef, position).AsTask();
            else
                return SendFuncs.SpawnInteractiveEntity(entityDef, position, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SpawnInteractiveEntityCreateDeferredDelegate(SharedCode.Entities.GameObjectEntities.InteractiveEntityDef entityDef, SharedCode.Utils.Vector3 position) => () =>
        {
            return SpawnInteractiveEntity(entityDef, position);
        }

        ;
        public async ValueTask SpawnInteractiveEntityRunMaster(SharedCode.Entities.GameObjectEntities.InteractiveEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SpawnInteractiveEntityCreateDeferredDelegate(entityDef, position), nameof(SpawnInteractiveEntity));
            }

            await SpawnInteractiveEntityRun(entityDef, position);
        }

        public async ValueTask SpawnInteractiveEntityRun(SharedCode.Entities.GameObjectEntities.InteractiveEntityDef entityDef, SharedCode.Utils.Vector3 position)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SpawnInteractiveEntity)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 7);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SpawnInteractiveEntityImpl(entityDef, position);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<string> GetRepositoryEntitiesCount()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return GetRepositoryEntitiesCountRunMaster().AsTask();
                else
                    return GetRepositoryEntitiesCountRun().AsTask();
            else
                return SendFuncs.GetRepositoryEntitiesCount(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<string>> GetRepositoryEntitiesCountCreateDeferredDelegate() => () =>
        {
            return GetRepositoryEntitiesCount();
        }

        ;
        public async ValueTask<string> GetRepositoryEntitiesCountRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(GetRepositoryEntitiesCountCreateDeferredDelegate(), nameof(GetRepositoryEntitiesCount));
            }

            return await GetRepositoryEntitiesCountRun();
        }

        public async ValueTask<string> GetRepositoryEntitiesCountRun()
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.TechnicalSupport, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(GetRepositoryEntitiesCount)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 8);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = GetRepositoryEntitiesCountImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<string> GetRepositoryEntitiesCountOnAllRepositories()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return GetRepositoryEntitiesCountOnAllRepositoriesRunMaster().AsTask();
                else
                    return GetRepositoryEntitiesCountOnAllRepositoriesRun().AsTask();
            else
                return SendFuncs.GetRepositoryEntitiesCountOnAllRepositories(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<string>> GetRepositoryEntitiesCountOnAllRepositoriesCreateDeferredDelegate() => () =>
        {
            return GetRepositoryEntitiesCountOnAllRepositories();
        }

        ;
        public async ValueTask<string> GetRepositoryEntitiesCountOnAllRepositoriesRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(GetRepositoryEntitiesCountOnAllRepositoriesCreateDeferredDelegate(), nameof(GetRepositoryEntitiesCountOnAllRepositories));
            }

            return await GetRepositoryEntitiesCountOnAllRepositoriesRun();
        }

        public async ValueTask<string> GetRepositoryEntitiesCountOnAllRepositoriesRun()
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.TechnicalSupport, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(GetRepositoryEntitiesCountOnAllRepositories)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 9);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = GetRepositoryEntitiesCountOnAllRepositoriesImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task DumpAllServerRepositories()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return DumpAllServerRepositoriesRunMaster().AsTask();
                else
                    return DumpAllServerRepositoriesRun().AsTask();
            else
                return SendFuncs.DumpAllServerRepositories(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> DumpAllServerRepositoriesCreateDeferredDelegate() => () =>
        {
            return DumpAllServerRepositories();
        }

        ;
        public async ValueTask DumpAllServerRepositoriesRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(DumpAllServerRepositoriesCreateDeferredDelegate(), nameof(DumpAllServerRepositories));
            }

            await DumpAllServerRepositoriesRun();
        }

        public async ValueTask DumpAllServerRepositoriesRun()
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.TechnicalSupport, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(DumpAllServerRepositories)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 10);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = DumpAllServerRepositoriesImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<string> SetVisibilityRadius(float enterRadius, float leaveRadius)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetVisibilityRadiusRunMaster(enterRadius, leaveRadius).AsTask();
                else
                    return SetVisibilityRadiusRun(enterRadius, leaveRadius).AsTask();
            else
                return SendFuncs.SetVisibilityRadius(enterRadius, leaveRadius, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<string>> SetVisibilityRadiusCreateDeferredDelegate(float enterRadius, float leaveRadius) => () =>
        {
            return SetVisibilityRadius(enterRadius, leaveRadius);
        }

        ;
        public async ValueTask<string> SetVisibilityRadiusRunMaster(float enterRadius, float leaveRadius)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetVisibilityRadiusCreateDeferredDelegate(enterRadius, leaveRadius), nameof(SetVisibilityRadius));
            }

            return await SetVisibilityRadiusRun(enterRadius, leaveRadius);
        }

        public async ValueTask<string> SetVisibilityRadiusRun(float enterRadius, float leaveRadius)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 11);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(SetVisibilityRadius)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = SetVisibilityRadiusImpl(enterRadius, leaveRadius);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            return await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                    else
                        return returnTask.Result;
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task<string> GetTooLongEntityWaitQueues()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return GetTooLongEntityWaitQueuesRunMaster().AsTask();
                else
                    return GetTooLongEntityWaitQueuesRun().AsTask();
            else
                return SendFuncs.GetTooLongEntityWaitQueues(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<string>> GetTooLongEntityWaitQueuesCreateDeferredDelegate() => () =>
        {
            return GetTooLongEntityWaitQueues();
        }

        ;
        public async ValueTask<string> GetTooLongEntityWaitQueuesRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(GetTooLongEntityWaitQueuesCreateDeferredDelegate(), nameof(GetTooLongEntityWaitQueues));
            }

            return await GetTooLongEntityWaitQueuesRun();
        }

        public async ValueTask<string> GetTooLongEntityWaitQueuesRun()
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(GetTooLongEntityWaitQueues)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 12);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = GetTooLongEntityWaitQueuesImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<int> GetCCU()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return GetCCURunMaster().AsTask();
                else
                    return GetCCURun().AsTask();
            else
                return SendFuncs.GetCCU(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<int>> GetCCUCreateDeferredDelegate() => () =>
        {
            return GetCCU();
        }

        ;
        public async ValueTask<int> GetCCURunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(GetCCUCreateDeferredDelegate(), nameof(GetCCU));
            }

            return await GetCCURun();
        }

        public async ValueTask<int> GetCCURun()
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(GetCCU)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 13);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = GetCCUImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetDebugMode(bool enabled)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetDebugModeRunMaster(enabled).AsTask();
                else
                    return SetDebugModeRun(enabled).AsTask();
            else
                return SendFuncs.SetDebugMode(enabled, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetDebugModeCreateDeferredDelegate(bool enabled) => () =>
        {
            return SetDebugMode(enabled);
        }

        ;
        public async ValueTask SetDebugModeRunMaster(bool enabled)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetDebugModeCreateDeferredDelegate(enabled), nameof(SetDebugMode));
            }

            await SetDebugModeRun(enabled);
        }

        public async ValueTask SetDebugModeRun(bool enabled)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetDebugMode)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 14);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetDebugModeImpl(enabled);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetDebugMobs(bool enabledStatus, bool hard)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetDebugMobsRunMaster(enabledStatus, hard).AsTask();
                else
                    return SetDebugMobsRun(enabledStatus, hard).AsTask();
            else
                return SendFuncs.SetDebugMobs(enabledStatus, hard, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetDebugMobsCreateDeferredDelegate(bool enabledStatus, bool hard) => () =>
        {
            return SetDebugMobs(enabledStatus, hard);
        }

        ;
        public async ValueTask SetDebugMobsRunMaster(bool enabledStatus, bool hard)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetDebugMobsCreateDeferredDelegate(enabledStatus, hard), nameof(SetDebugMobs));
            }

            await SetDebugMobsRun(enabledStatus, hard);
        }

        public async ValueTask SetDebugMobsRun(bool enabledStatus, bool hard)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetDebugMobs)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 15);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetDebugMobsImpl(enabledStatus, hard);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetDebugSpells(bool enabledStatus)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetDebugSpellsRunMaster(enabledStatus).AsTask();
                else
                    return SetDebugSpellsRun(enabledStatus).AsTask();
            else
                return SendFuncs.SetDebugSpells(enabledStatus, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetDebugSpellsCreateDeferredDelegate(bool enabledStatus) => () =>
        {
            return SetDebugSpells(enabledStatus);
        }

        ;
        public async ValueTask SetDebugSpellsRunMaster(bool enabledStatus)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetDebugSpellsCreateDeferredDelegate(enabledStatus), nameof(SetDebugSpells));
            }

            await SetDebugSpellsRun(enabledStatus);
        }

        public async ValueTask SetDebugSpellsRun(bool enabledStatus)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetDebugSpells)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 16);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetDebugSpellsImpl(enabledStatus);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task PrintBrokenLocomotions()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return PrintBrokenLocomotionsRunMaster().AsTask();
                else
                    return PrintBrokenLocomotionsRun().AsTask();
            else
                return SendFuncs.PrintBrokenLocomotions(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> PrintBrokenLocomotionsCreateDeferredDelegate() => () =>
        {
            return PrintBrokenLocomotions();
        }

        ;
        public async ValueTask PrintBrokenLocomotionsRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(PrintBrokenLocomotionsCreateDeferredDelegate(), nameof(PrintBrokenLocomotions));
            }

            await PrintBrokenLocomotionsRun();
        }

        public async ValueTask PrintBrokenLocomotionsRun()
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(PrintBrokenLocomotions)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 17);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = PrintBrokenLocomotionsImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public ValueTask DamageAllItems(System.Guid character, float percent)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return DamageAllItemsRunMaster(character, percent);
                else
                    return DamageAllItemsRun(character, percent);
            else
                return SendFuncs.DamageAllItems(character, percent, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId());
        }

        private Func<Task> DamageAllItemsCreateDeferredDelegate(System.Guid character, float percent) => () =>
        {
            return DamageAllItems(character, percent).AsTask();
        }

        ;
        public async ValueTask DamageAllItemsRunMaster(System.Guid character, float percent)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(DamageAllItemsCreateDeferredDelegate(character, percent), nameof(DamageAllItems));
            }

            await DamageAllItemsRun(character, percent);
        }

        public async ValueTask DamageAllItemsRun(System.Guid character, float percent)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(DamageAllItems)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 18);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = DamageAllItemsImpl(character, percent);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetDebugMobPositionLogging(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> outerRef, bool enabledStatus, bool dump)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetDebugMobPositionLoggingRunMaster(outerRef, enabledStatus, dump).AsTask();
                else
                    return SetDebugMobPositionLoggingRun(outerRef, enabledStatus, dump).AsTask();
            else
                return SendFuncs.SetDebugMobPositionLogging(outerRef, enabledStatus, dump, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetDebugMobPositionLoggingCreateDeferredDelegate(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> outerRef, bool enabledStatus, bool dump) => () =>
        {
            return SetDebugMobPositionLogging(outerRef, enabledStatus, dump);
        }

        ;
        public async ValueTask SetDebugMobPositionLoggingRunMaster(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> outerRef, bool enabledStatus, bool dump)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetDebugMobPositionLoggingCreateDeferredDelegate(outerRef, enabledStatus, dump), nameof(SetDebugMobPositionLogging));
            }

            await SetDebugMobPositionLoggingRun(outerRef, enabledStatus, dump);
        }

        public async ValueTask SetDebugMobPositionLoggingRun(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> outerRef, bool enabledStatus, bool dump)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetDebugMobPositionLogging)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 19);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetDebugMobPositionLoggingImpl(outerRef, enabledStatus, dump);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetCurveLoggerState(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> charRef, bool enabledStatus, bool dump, bool serverOnly, string loggerName, System.Guid dumpId)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetCurveLoggerStateRunMaster(charRef, enabledStatus, dump, serverOnly, loggerName, dumpId).AsTask();
                else
                    return SetCurveLoggerStateRun(charRef, enabledStatus, dump, serverOnly, loggerName, dumpId).AsTask();
            else
                return SendFuncs.SetCurveLoggerState(charRef, enabledStatus, dump, serverOnly, loggerName, dumpId, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetCurveLoggerStateCreateDeferredDelegate(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> charRef, bool enabledStatus, bool dump, bool serverOnly, string loggerName, System.Guid dumpId) => () =>
        {
            return SetCurveLoggerState(charRef, enabledStatus, dump, serverOnly, loggerName, dumpId);
        }

        ;
        public async ValueTask SetCurveLoggerStateRunMaster(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> charRef, bool enabledStatus, bool dump, bool serverOnly, string loggerName, System.Guid dumpId)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetCurveLoggerStateCreateDeferredDelegate(charRef, enabledStatus, dump, serverOnly, loggerName, dumpId), nameof(SetCurveLoggerState));
            }

            await SetCurveLoggerStateRun(charRef, enabledStatus, dump, serverOnly, loggerName, dumpId);
        }

        public async ValueTask SetCurveLoggerStateRun(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> charRef, bool enabledStatus, bool dump, bool serverOnly, string loggerName, System.Guid dumpId)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetCurveLoggerState)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 20);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetCurveLoggerStateImpl(charRef, enabledStatus, dump, serverOnly, loggerName, dumpId);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetLoggableEnable(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> outerRef, bool enabledStatus)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetLoggableEnableRunMaster(outerRef, enabledStatus).AsTask();
                else
                    return SetLoggableEnableRun(outerRef, enabledStatus).AsTask();
            else
                return SendFuncs.SetLoggableEnable(outerRef, enabledStatus, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetLoggableEnableCreateDeferredDelegate(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> outerRef, bool enabledStatus) => () =>
        {
            return SetLoggableEnable(outerRef, enabledStatus);
        }

        ;
        public async ValueTask SetLoggableEnableRunMaster(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> outerRef, bool enabledStatus)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetLoggableEnableCreateDeferredDelegate(outerRef, enabledStatus), nameof(SetLoggableEnable));
            }

            await SetLoggableEnableRun(outerRef, enabledStatus);
        }

        public async ValueTask SetLoggableEnableRun(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> outerRef, bool enabledStatus)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetLoggableEnable)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 21);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetLoggableEnableImpl(outerRef, enabledStatus);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task MainUnityThreadOnServerSleep(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> charRef, bool isOn, float sleepTime, float delayBeforeSleep, float repeatTime)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return MainUnityThreadOnServerSleepRunMaster(charRef, isOn, sleepTime, delayBeforeSleep, repeatTime).AsTask();
                else
                    return MainUnityThreadOnServerSleepRun(charRef, isOn, sleepTime, delayBeforeSleep, repeatTime).AsTask();
            else
                return SendFuncs.MainUnityThreadOnServerSleep(charRef, isOn, sleepTime, delayBeforeSleep, repeatTime, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> MainUnityThreadOnServerSleepCreateDeferredDelegate(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> charRef, bool isOn, float sleepTime, float delayBeforeSleep, float repeatTime) => () =>
        {
            return MainUnityThreadOnServerSleep(charRef, isOn, sleepTime, delayBeforeSleep, repeatTime);
        }

        ;
        public async ValueTask MainUnityThreadOnServerSleepRunMaster(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> charRef, bool isOn, float sleepTime, float delayBeforeSleep, float repeatTime)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(MainUnityThreadOnServerSleepCreateDeferredDelegate(charRef, isOn, sleepTime, delayBeforeSleep, repeatTime), nameof(MainUnityThreadOnServerSleep));
            }

            await MainUnityThreadOnServerSleepRun(charRef, isOn, sleepTime, delayBeforeSleep, repeatTime);
        }

        public async ValueTask MainUnityThreadOnServerSleepRun(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> charRef, bool isOn, float sleepTime, float delayBeforeSleep, float repeatTime)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(MainUnityThreadOnServerSleep)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 22);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = MainUnityThreadOnServerSleepImpl(charRef, isOn, sleepTime, delayBeforeSleep, repeatTime);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<bool> ChangeHealth(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> victimEntity, int deltaValue)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return ChangeHealthRunMaster(victimEntity, deltaValue).AsTask();
                else
                    return ChangeHealthRun(victimEntity, deltaValue).AsTask();
            else
                return SendFuncs.ChangeHealth(victimEntity, deltaValue, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<bool>> ChangeHealthCreateDeferredDelegate(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> victimEntity, int deltaValue) => () =>
        {
            return ChangeHealth(victimEntity, deltaValue);
        }

        ;
        public async ValueTask<bool> ChangeHealthRunMaster(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> victimEntity, int deltaValue)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(ChangeHealthCreateDeferredDelegate(victimEntity, deltaValue), nameof(ChangeHealth));
            }

            return await ChangeHealthRun(victimEntity, deltaValue);
        }

        public async ValueTask<bool> ChangeHealthRun(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> victimEntity, int deltaValue)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(ChangeHealth)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 23);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = ChangeHealthImpl(victimEntity, deltaValue);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<bool> Godmode(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> applicantEntityRef, bool enable)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return GodmodeRunMaster(applicantEntityRef, enable).AsTask();
                else
                    return GodmodeRun(applicantEntityRef, enable).AsTask();
            else
                return SendFuncs.Godmode(applicantEntityRef, enable, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<bool>> GodmodeCreateDeferredDelegate(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> applicantEntityRef, bool enable) => () =>
        {
            return Godmode(applicantEntityRef, enable);
        }

        ;
        public async ValueTask<bool> GodmodeRunMaster(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> applicantEntityRef, bool enable)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(GodmodeCreateDeferredDelegate(applicantEntityRef, enable), nameof(Godmode));
            }

            return await GodmodeRun(applicantEntityRef, enable);
        }

        public async ValueTask<bool> GodmodeRun(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> applicantEntityRef, bool enable)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(Godmode)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 24);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = GodmodeImpl(applicantEntityRef, enable);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task Version01()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return Version01RunMaster().AsTask();
                else
                    return Version01Run().AsTask();
            else
                return SendFuncs.Version01(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> Version01CreateDeferredDelegate() => () =>
        {
            return Version01();
        }

        ;
        public async ValueTask Version01RunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(Version01CreateDeferredDelegate(), nameof(Version01));
            }

            await Version01Run();
        }

        public async ValueTask Version01Run()
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.TechnicalSupport, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(Version01)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 25);
            GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = Version01Impl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<SharedCode.Utils.Vector3[]> ResolveCharacterCoords(System.Guid[] guids)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return ResolveCharacterCoordsRunMaster(guids).AsTask();
                else
                    return ResolveCharacterCoordsRun(guids).AsTask();
            else
                return SendFuncs.ResolveCharacterCoords(guids, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<SharedCode.Utils.Vector3[]>> ResolveCharacterCoordsCreateDeferredDelegate(System.Guid[] guids) => () =>
        {
            return ResolveCharacterCoords(guids);
        }

        ;
        public async ValueTask<SharedCode.Utils.Vector3[]> ResolveCharacterCoordsRunMaster(System.Guid[] guids)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(ResolveCharacterCoordsCreateDeferredDelegate(guids), nameof(ResolveCharacterCoords));
            }

            return await ResolveCharacterCoordsRun(guids);
        }

        public async ValueTask<SharedCode.Utils.Vector3[]> ResolveCharacterCoordsRun(System.Guid[] guids)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(ResolveCharacterCoords)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 26);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = ResolveCharacterCoordsImpl(guids);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task ForceGC(int count, System.Guid repositoryId)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return ForceGCRunMaster(count, repositoryId).AsTask();
                else
                    return ForceGCRun(count, repositoryId).AsTask();
            else
                return SendFuncs.ForceGC(count, repositoryId, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> ForceGCCreateDeferredDelegate(int count, System.Guid repositoryId) => () =>
        {
            return ForceGC(count, repositoryId);
        }

        ;
        public async ValueTask ForceGCRunMaster(int count, System.Guid repositoryId)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(ForceGCCreateDeferredDelegate(count, repositoryId), nameof(ForceGC));
            }

            await ForceGCRun(count, repositoryId);
        }

        public async ValueTask ForceGCRun(int count, System.Guid repositoryId)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(ForceGC)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 27);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = ForceGCImpl(count, repositoryId);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task ForceSelfCompactionGC()
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return ForceSelfCompactionGCRunMaster().AsTask();
                else
                    return ForceSelfCompactionGCRun().AsTask();
            else
                return SendFuncs.ForceSelfCompactionGC(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> ForceSelfCompactionGCCreateDeferredDelegate() => () =>
        {
            return ForceSelfCompactionGC();
        }

        ;
        public async ValueTask ForceSelfCompactionGCRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(ForceSelfCompactionGCCreateDeferredDelegate(), nameof(ForceSelfCompactionGC));
            }

            await ForceSelfCompactionGCRun();
        }

        public async ValueTask ForceSelfCompactionGCRun()
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 28);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = ForceSelfCompactionGCImpl();
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetGCEnabled(bool enabled, System.Guid repositoryId)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetGCEnabledRunMaster(enabled, repositoryId).AsTask();
                else
                    return SetGCEnabledRun(enabled, repositoryId).AsTask();
            else
                return SendFuncs.SetGCEnabled(enabled, repositoryId, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetGCEnabledCreateDeferredDelegate(bool enabled, System.Guid repositoryId) => () =>
        {
            return SetGCEnabled(enabled, repositoryId);
        }

        ;
        public async ValueTask SetGCEnabledRunMaster(bool enabled, System.Guid repositoryId)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetGCEnabledCreateDeferredDelegate(enabled, repositoryId), nameof(SetGCEnabled));
            }

            await SetGCEnabledRun(enabled, repositoryId);
        }

        public async ValueTask SetGCEnabledRun(bool enabled, System.Guid repositoryId)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetGCEnabled)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 29);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetGCEnabledImpl(enabled, repositoryId);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task CastSpell(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> entityRef, SharedCode.Wizardry.SpellCast spellCast)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return CastSpellRunMaster(entityRef, spellCast).AsTask();
                else
                    return CastSpellRun(entityRef, spellCast).AsTask();
            else
                return SendFuncs.CastSpell(entityRef, spellCast, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> CastSpellCreateDeferredDelegate(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> entityRef, SharedCode.Wizardry.SpellCast spellCast) => () =>
        {
            return CastSpell(entityRef, spellCast);
        }

        ;
        public async ValueTask CastSpellRunMaster(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> entityRef, SharedCode.Wizardry.SpellCast spellCast)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(CastSpellCreateDeferredDelegate(entityRef, spellCast), nameof(CastSpell));
            }

            await CastSpellRun(entityRef, spellCast);
        }

        public async ValueTask CastSpellRun(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> entityRef, SharedCode.Wizardry.SpellCast spellCast)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(CastSpell)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 30);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = CastSpellImpl(entityRef, spellCast);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetServerCheatVariable(Assets.Src.ResourcesSystem.Base.BaseResource resource, string value)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetServerCheatVariableRunMaster(resource, value).AsTask();
                else
                    return SetServerCheatVariableRun(resource, value).AsTask();
            else
                return SendFuncs.SetServerCheatVariable(resource, value, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetServerCheatVariableCreateDeferredDelegate(Assets.Src.ResourcesSystem.Base.BaseResource resource, string value) => () =>
        {
            return SetServerCheatVariable(resource, value);
        }

        ;
        public async ValueTask SetServerCheatVariableRunMaster(Assets.Src.ResourcesSystem.Base.BaseResource resource, string value)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetServerCheatVariableCreateDeferredDelegate(resource, value), nameof(SetServerCheatVariable));
            }

            await SetServerCheatVariableRun(resource, value);
        }

        public async ValueTask SetServerCheatVariableRun(Assets.Src.ResourcesSystem.Base.BaseResource resource, string value)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetServerCheatVariable)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 31);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetServerCheatVariableImpl(resource, value);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> TestCheckPZ15200Done(float waitBeforeReplicate)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return TestCheckPZ15200DoneRunMaster(waitBeforeReplicate).AsTask();
                else
                    return TestCheckPZ15200DoneRun(waitBeforeReplicate).AsTask();
            else
                return SendFuncs.TestCheckPZ15200Done(waitBeforeReplicate, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>>> TestCheckPZ15200DoneCreateDeferredDelegate(float waitBeforeReplicate) => () =>
        {
            return TestCheckPZ15200Done(waitBeforeReplicate);
        }

        ;
        public async ValueTask<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> TestCheckPZ15200DoneRunMaster(float waitBeforeReplicate)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(TestCheckPZ15200DoneCreateDeferredDelegate(waitBeforeReplicate), nameof(TestCheckPZ15200Done));
            }

            return await TestCheckPZ15200DoneRun(waitBeforeReplicate);
        }

        public async ValueTask<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> TestCheckPZ15200DoneRun(float waitBeforeReplicate)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(TestCheckPZ15200Done)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 32);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = TestCheckPZ15200DoneImpl(waitBeforeReplicate);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        return await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
                else
                    return returnTask.Result;
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task EnableWizardLogger(ResourceSystem.Utils.OuterRef entity, bool enable)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return EnableWizardLoggerRunMaster(entity, enable).AsTask();
                else
                    return EnableWizardLoggerRun(entity, enable).AsTask();
            else
                return SendFuncs.EnableWizardLogger(entity, enable, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> EnableWizardLoggerCreateDeferredDelegate(ResourceSystem.Utils.OuterRef entity, bool enable) => () =>
        {
            return EnableWizardLogger(entity, enable);
        }

        ;
        public async ValueTask EnableWizardLoggerRunMaster(ResourceSystem.Utils.OuterRef entity, bool enable)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(EnableWizardLoggerCreateDeferredDelegate(entity, enable), nameof(EnableWizardLogger));
            }

            await EnableWizardLoggerRun(entity, enable);
        }

        public async ValueTask EnableWizardLoggerRun(ResourceSystem.Utils.OuterRef entity, bool enable)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(EnableWizardLogger)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 33);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = EnableWizardLoggerImpl(entity, enable);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task SetGender(ResourceSystem.Utils.OuterRef entity, ResourceSystem.Aspects.Misc.GenderDef gender)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetGenderRunMaster(entity, gender).AsTask();
                else
                    return SetGenderRun(entity, gender).AsTask();
            else
                return SendFuncs.SetGender(entity, gender, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetGenderCreateDeferredDelegate(ResourceSystem.Utils.OuterRef entity, ResourceSystem.Aspects.Misc.GenderDef gender) => () =>
        {
            return SetGender(entity, gender);
        }

        ;
        public async ValueTask SetGenderRunMaster(ResourceSystem.Utils.OuterRef entity, ResourceSystem.Aspects.Misc.GenderDef gender)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetGenderCreateDeferredDelegate(entity, gender), nameof(SetGender));
            }

            await SetGenderRun(entity, gender);
        }

        public async ValueTask SetGenderRun(ResourceSystem.Utils.OuterRef entity, ResourceSystem.Aspects.Misc.GenderDef gender)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(SetGender)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 34);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = SetGenderImpl(entity, gender);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task InvokeTrauma(ResourceSystem.Utils.OuterRef entity, string trauma)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return InvokeTraumaRunMaster(entity, trauma).AsTask();
                else
                    return InvokeTraumaRun(entity, trauma).AsTask();
            else
                return SendFuncs.InvokeTrauma(entity, trauma, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> InvokeTraumaCreateDeferredDelegate(ResourceSystem.Utils.OuterRef entity, string trauma) => () =>
        {
            return InvokeTrauma(entity, trauma);
        }

        ;
        public async ValueTask InvokeTraumaRunMaster(ResourceSystem.Utils.OuterRef entity, string trauma)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(InvokeTraumaCreateDeferredDelegate(entity, trauma), nameof(InvokeTrauma));
            }

            await InvokeTraumaRun(entity, trauma);
        }

        public async ValueTask InvokeTraumaRun(ResourceSystem.Utils.OuterRef entity, string trauma)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(InvokeTrauma)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 35);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = InvokeTraumaImpl(entity, trauma);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task StopTrauma(ResourceSystem.Utils.OuterRef entity, string trauma)
        {
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return StopTraumaRunMaster(entity, trauma).AsTask();
                else
                    return StopTraumaRun(entity, trauma).AsTask();
            else
                return SendFuncs.StopTrauma(entity, trauma, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> StopTraumaCreateDeferredDelegate(ResourceSystem.Utils.OuterRef entity, string trauma) => () =>
        {
            return StopTrauma(entity, trauma);
        }

        ;
        public async ValueTask StopTraumaRunMaster(ResourceSystem.Utils.OuterRef entity, string trauma)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(StopTraumaCreateDeferredDelegate(entity, trauma), nameof(StopTrauma));
            }

            await StopTraumaRun(entity, trauma);
        }

        public async ValueTask StopTraumaRun(ResourceSystem.Utils.OuterRef entity, string trauma)
        {
            if (!await global::GeneratedCode.Shared.Utils.AccountTypeUtils.CheckAccountType(GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, SharedCode.Entities.Service.AccountType.GameMaster, EntitiesRepository))
                throw new System.UnauthorizedAccessException(string.Format("User {0} has no rights to use cheat {1}", GeneratedCode.Manual.Repositories.CallbackRepositoryHolder.CurrentCallbackRepositoryId, nameof(StopTrauma)));
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 36);
            global::GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var returnTask = StopTraumaImpl(entity, trauma);
                if (!returnTask.IsCompleted || returnTask.IsFaulted)
                {
                    var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                    try
                    {
                        await returnTask;
                    }
                    finally
                    {
                        ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                    }
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public event System.Func<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>, bool, bool, string, System.Guid, System.Threading.Tasks.Task> SetCurveLoggerEvent;
        public async Task OnSetCurveLoggerEventInvoke(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> arg1, bool arg2, bool arg3, string arg4, System.Guid arg5)
        {
            if (SetCurveLoggerEvent == null)
                return;
            foreach (var subscriber in SetCurveLoggerEvent.GetInvocationList().Cast<System.Func<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>, bool, bool, string, System.Guid, System.Threading.Tasks.Task>>())
            {
                try
                {
                    using (var cts = new CancellationTokenSource())
                    {
                        var __timeoutTask__ = Task.Delay(TimeSpan.FromSeconds(ServerCoreRuntimeParameters.EntityEventTimeoutSeconds), cts.Token);
                        var __subscriberTask__ = subscriber(arg1, arg2, arg3, arg4, arg5);
                        await Task.WhenAny(__subscriberTask__, __timeoutTask__);
                        if (!__subscriberTask__.IsCompleted)
                        {
                            Core.Environment.Logging.Extension.LoggerExtensions.IfError(Log.Logger)?.Message("{0} process event obj {1} method {2} timeout: {3}", nameof(SetCurveLoggerEvent), subscriber.Target?.GetType().Name ?? "unknown", subscriber?.Method.Name ?? "unknown", ServerCoreRuntimeParameters.EntityEventTimeoutSeconds).Write();
                            var __sw__ = new System.Diagnostics.Stopwatch();
                            __sw__.Start();
                            await __subscriberTask__;
                            __sw__.Stop();
                            Core.Environment.Logging.Extension.LoggerExtensions.IfError(Log.Logger)?.Message("{0} process event obj {1} method {2} executing too long: {3} seconds", nameof(SetCurveLoggerEvent), subscriber.Target?.GetType().Name ?? "unknown", subscriber?.Method.Name ?? "unknown", ServerCoreRuntimeParameters.EntityEventTimeoutSeconds + __sw__.Elapsed.TotalSeconds).Write();
                        }
                        else
                        {
                            cts.Cancel();
                            if (__subscriberTask__.IsFaulted)
                                Core.Environment.Logging.Extension.LoggerExtensions.IfError(Log.Logger)?.Message(__subscriberTask__.Exception, "Exception in {0} process event obj {1} method {2}", nameof(SetCurveLoggerEvent), subscriber.Target?.GetType().Name ?? "unknown", subscriber?.Method.Name ?? "unknown").Write();
                        }
                    }
                }
                catch (Exception e)
                {
                    Core.Environment.Logging.Extension.LoggerExtensions.IfError(Log.Logger)?.Message(e, "Exception in {0} event obj {1} method {2}", nameof(SetCurveLoggerEvent), subscriber?.Target?.GetType().Name ?? "unknown", subscriber?.Method.Name ?? "unknown").Write();
                }
                finally
                {
                    GeneratedCode.Manual.Repositories.AsyncStackHolder.AssertNoChildren();
                }
            }
        }

        public async Task OnSetCurveLoggerEvent(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> arg1, bool arg2, bool arg3, string arg4, System.Guid arg5)
        {
            if (this.IsMaster())
            {
                GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.Service.ICheatServiceEntity), 37);
                INetworkProxy[] __networkProxies__ = this.GatherMessageTargets(SharedCode.EntitySystem.ReplicationLevel.ClientBroadcast, typeof(SharedCode.Entities.Service.ICheatServiceEntity), 37).ToArray();
                if (__networkProxies__.Length > 0)
                    await SendFuncs.OnSetCurveLoggerEvent(arg1, arg2, arg3, arg4, arg5, this, __networkProxies__, this.EntitiesRepository, GetActualMigratingId());
            }

            await OnSetCurveLoggerEventInvoke(arg1, arg2, arg3, arg4, arg5);
        }
    }
}