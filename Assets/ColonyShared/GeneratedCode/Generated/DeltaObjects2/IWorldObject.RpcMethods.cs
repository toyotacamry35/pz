// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using System.Threading;
using System.Threading.Tasks;
using GeneratedCode.EntitySystem;
using SharedCode.Logging;
using System.Linq;
using SharedCode.EntitySystem;
using SharedCode.Network;

namespace GeneratedCode.DeltaObjects
{
    public partial class LimitedLifetime
    {
        public ValueTask<Assets.ColonyShared.SharedCode.Aspects.WorldObjects.LimitedLifetimeDef> GetLimitedLifetimeDef()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.NeedDeferredRpcOnMigrating())
                return GetLimitedLifetimeDefRunMaster();
            else
                return GetLimitedLifetimeDefRun();
        }

        private Func<Task<Assets.ColonyShared.SharedCode.Aspects.WorldObjects.LimitedLifetimeDef>> GetLimitedLifetimeDefCreateDeferredDelegate() => () =>
        {
            return GetLimitedLifetimeDef().AsTask();
        }

        ;
        public async ValueTask<Assets.ColonyShared.SharedCode.Aspects.WorldObjects.LimitedLifetimeDef> GetLimitedLifetimeDefRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(GetLimitedLifetimeDefCreateDeferredDelegate(), nameof(GetLimitedLifetimeDef));
            }

            return await GetLimitedLifetimeDefRun();
        }

        public async ValueTask<Assets.ColonyShared.SharedCode.Aspects.WorldObjects.LimitedLifetimeDef> GetLimitedLifetimeDefRun()
        {
            this.CheckValidateEntityInAsyncContext();
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ILimitedLifetime), 0);
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                try
                {
                    return await GetLimitedLifetimeDefImpl();
                }
                finally
                {
                    ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<long> GetLifetimeLimit()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.NeedDeferredRpcOnMigrating())
                return GetLifetimeLimitRunMaster().AsTask();
            else
                return GetLifetimeLimitRun().AsTask();
        }

        private Func<Task<long>> GetLifetimeLimitCreateDeferredDelegate() => () =>
        {
            return GetLifetimeLimit();
        }

        ;
        public async ValueTask<long> GetLifetimeLimitRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(GetLifetimeLimitCreateDeferredDelegate(), nameof(GetLifetimeLimit));
            }

            return await GetLifetimeLimitRun();
        }

        public async Task<long> GetLifetimeLimitRun()
        {
            this.CheckValidateEntityInAsyncContext();
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ILimitedLifetime), 1);
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                try
                {
                    return await GetLifetimeLimitImpl();
                }
                finally
                {
                    ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<SharedCode.EntitySystem.ChainCalls.ChainCancellationToken> StartCountdown()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.NeedDeferredRpcOnMigrating())
                return StartCountdownRunMaster().AsTask();
            else
                return StartCountdownRun().AsTask();
        }

        private Func<Task<SharedCode.EntitySystem.ChainCalls.ChainCancellationToken>> StartCountdownCreateDeferredDelegate() => () =>
        {
            return StartCountdown();
        }

        ;
        public async ValueTask<SharedCode.EntitySystem.ChainCalls.ChainCancellationToken> StartCountdownRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(StartCountdownCreateDeferredDelegate(), nameof(StartCountdown));
            }

            return await StartCountdownRun();
        }

        public async Task<SharedCode.EntitySystem.ChainCalls.ChainCancellationToken> StartCountdownRun()
        {
            this.CheckValidateEntityInAsyncContext();
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ILimitedLifetime), 2);
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                try
                {
                    return await StartCountdownImpl();
                }
                finally
                {
                    ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }
    }
}

namespace GeneratedCode.DeltaObjects
{
    public partial class OpenMechanics
    {
        public Task FirstOpenedOrLastClosedExternalCall(bool isOpened)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return FirstOpenedOrLastClosedExternalCallRunMaster(isOpened).AsTask();
                else
                    return FirstOpenedOrLastClosedExternalCallRun(isOpened).AsTask();
            else
                return SendFuncs.FirstOpenedOrLastClosedExternalCall(isOpened, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> FirstOpenedOrLastClosedExternalCallCreateDeferredDelegate(bool isOpened) => () =>
        {
            return FirstOpenedOrLastClosedExternalCall(isOpened);
        }

        ;
        public async ValueTask FirstOpenedOrLastClosedExternalCallRunMaster(bool isOpened)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(FirstOpenedOrLastClosedExternalCallCreateDeferredDelegate(isOpened), nameof(FirstOpenedOrLastClosedExternalCall));
            }

            await FirstOpenedOrLastClosedExternalCallRun(isOpened);
        }

        public async ValueTask FirstOpenedOrLastClosedExternalCallRun(bool isOpened)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.IOpenMechanics), 0);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(FirstOpenedOrLastClosedExternalCall)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = FirstOpenedOrLastClosedExternalCallImpl(isOpened);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task<ResourceSystem.Utils.OuterRef> TryOpen(ResourceSystem.Utils.OuterRef outerRef)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return TryOpenRunMaster(outerRef).AsTask();
                else
                    return TryOpenRun(outerRef).AsTask();
            else
                return SendFuncs.TryOpen(outerRef, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<ResourceSystem.Utils.OuterRef>> TryOpenCreateDeferredDelegate(ResourceSystem.Utils.OuterRef outerRef) => () =>
        {
            return TryOpen(outerRef);
        }

        ;
        public async ValueTask<ResourceSystem.Utils.OuterRef> TryOpenRunMaster(ResourceSystem.Utils.OuterRef outerRef)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(TryOpenCreateDeferredDelegate(outerRef), nameof(TryOpen));
            }

            return await TryOpenRun(outerRef);
        }

        public async ValueTask<ResourceSystem.Utils.OuterRef> TryOpenRun(ResourceSystem.Utils.OuterRef outerRef)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.IOpenMechanics), 1);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(TryOpen)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = TryOpenImpl(outerRef);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            return await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                    else
                        return returnTask.Result;
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task<bool> TryClose(ResourceSystem.Utils.OuterRef outerRef)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return TryCloseRunMaster(outerRef).AsTask();
                else
                    return TryCloseRun(outerRef).AsTask();
            else
                return SendFuncs.TryClose(outerRef, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<bool>> TryCloseCreateDeferredDelegate(ResourceSystem.Utils.OuterRef outerRef) => () =>
        {
            return TryClose(outerRef);
        }

        ;
        public async ValueTask<bool> TryCloseRunMaster(ResourceSystem.Utils.OuterRef outerRef)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(TryCloseCreateDeferredDelegate(outerRef), nameof(TryClose));
            }

            return await TryCloseRun(outerRef);
        }

        public async ValueTask<bool> TryCloseRun(ResourceSystem.Utils.OuterRef outerRef)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.IOpenMechanics), 2);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(TryClose)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = TryCloseImpl(outerRef);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            return await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                    else
                        return returnTask.Result;
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public ValueTask<bool> IsEmpty()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.NeedDeferredRpcOnMigrating())
                return IsEmptyRunMaster();
            else
                return IsEmptyRun();
        }

        private Func<Task<bool>> IsEmptyCreateDeferredDelegate() => () =>
        {
            return IsEmpty().AsTask();
        }

        ;
        public async ValueTask<bool> IsEmptyRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(IsEmptyCreateDeferredDelegate(), nameof(IsEmpty));
            }

            return await IsEmptyRun();
        }

        public async ValueTask<bool> IsEmptyRun()
        {
            this.CheckValidateEntityInAsyncContext();
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.IOpenMechanics), 3);
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                try
                {
                    return await IsEmptyImpl();
                }
                finally
                {
                    ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public event System.Func<bool, System.Threading.Tasks.Task> FirstOpenedOrLastClosed;
        public async Task OnFirstOpenedOrLastClosedInvoke(bool arg)
        {
            if (FirstOpenedOrLastClosed == null)
                return;
            foreach (var subscriber in FirstOpenedOrLastClosed.GetInvocationList().Cast<System.Func<bool, System.Threading.Tasks.Task>>())
            {
                try
                {
                    using (var cts = new CancellationTokenSource())
                    {
                        var __timeoutTask__ = Task.Delay(TimeSpan.FromSeconds(ServerCoreRuntimeParameters.EntityEventTimeoutSeconds), cts.Token);
                        var __subscriberTask__ = subscriber(arg);
                        await Task.WhenAny(__subscriberTask__, __timeoutTask__);
                        if (!__subscriberTask__.IsCompleted)
                        {
                            Core.Environment.Logging.Extension.LoggerExtensions.IfError(Log.Logger)?.Message("{0} process event obj {1} method {2} timeout: {3}", nameof(FirstOpenedOrLastClosed), subscriber.Target?.GetType().Name ?? "unknown", subscriber?.Method.Name ?? "unknown", ServerCoreRuntimeParameters.EntityEventTimeoutSeconds).Write();
                            var __sw__ = new System.Diagnostics.Stopwatch();
                            __sw__.Start();
                            await __subscriberTask__;
                            __sw__.Stop();
                            Core.Environment.Logging.Extension.LoggerExtensions.IfError(Log.Logger)?.Message("{0} process event obj {1} method {2} executing too long: {3} seconds", nameof(FirstOpenedOrLastClosed), subscriber.Target?.GetType().Name ?? "unknown", subscriber?.Method.Name ?? "unknown", ServerCoreRuntimeParameters.EntityEventTimeoutSeconds + __sw__.Elapsed.TotalSeconds).Write();
                        }
                        else
                        {
                            cts.Cancel();
                            if (__subscriberTask__.IsFaulted)
                                Core.Environment.Logging.Extension.LoggerExtensions.IfError(Log.Logger)?.Message(__subscriberTask__.Exception, "Exception in {0} process event obj {1} method {2}", nameof(FirstOpenedOrLastClosed), subscriber.Target?.GetType().Name ?? "unknown", subscriber?.Method.Name ?? "unknown").Write();
                        }
                    }
                }
                catch (Exception e)
                {
                    Core.Environment.Logging.Extension.LoggerExtensions.IfError(Log.Logger)?.Message(e, "Exception in {0} event obj {1} method {2}", nameof(FirstOpenedOrLastClosed), subscriber?.Target?.GetType().Name ?? "unknown", subscriber?.Method.Name ?? "unknown").Write();
                }
                finally
                {
                    GeneratedCode.Manual.Repositories.AsyncStackHolder.AssertNoChildren();
                }
            }
        }

        public async Task OnFirstOpenedOrLastClosed(bool arg)
        {
            if (this.IsMaster())
            {
                GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.IOpenMechanics), 4);
                INetworkProxy[] __networkProxies__ = this.GatherMessageTargets(SharedCode.EntitySystem.ReplicationLevel.Master, typeof(SharedCode.Entities.IOpenMechanics), 4).ToArray();
                if (__networkProxies__.Length > 0)
                    await SendFuncs.OnFirstOpenedOrLastClosed(arg, this, __networkProxies__, this.EntitiesRepository, GetActualMigratingId());
            }

            await OnFirstOpenedOrLastClosedInvoke(arg);
        }
    }
}

namespace GeneratedCode.DeltaObjects
{
    public partial class Traumas
    {
        public Task ChangeTraumaPoints(string traumaKey, int delta)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return ChangeTraumaPointsRunMaster(traumaKey, delta).AsTask();
                else
                    return ChangeTraumaPointsRun(traumaKey, delta).AsTask();
            else
                return SendFuncs.ChangeTraumaPoints(traumaKey, delta, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> ChangeTraumaPointsCreateDeferredDelegate(string traumaKey, int delta) => () =>
        {
            return ChangeTraumaPoints(traumaKey, delta);
        }

        ;
        public async ValueTask ChangeTraumaPointsRunMaster(string traumaKey, int delta)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(ChangeTraumaPointsCreateDeferredDelegate(traumaKey, delta), nameof(ChangeTraumaPoints));
            }

            await ChangeTraumaPointsRun(traumaKey, delta);
        }

        public async ValueTask ChangeTraumaPointsRun(string traumaKey, int delta)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 0);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(ChangeTraumaPoints)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = ChangeTraumaPointsImpl(traumaKey, delta);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task StartTrauma(string traumaKey)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return StartTraumaRunMaster(traumaKey).AsTask();
                else
                    return StartTraumaRun(traumaKey).AsTask();
            else
                return SendFuncs.StartTrauma(traumaKey, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> StartTraumaCreateDeferredDelegate(string traumaKey) => () =>
        {
            return StartTrauma(traumaKey);
        }

        ;
        public async ValueTask StartTraumaRunMaster(string traumaKey)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(StartTraumaCreateDeferredDelegate(traumaKey), nameof(StartTrauma));
            }

            await StartTraumaRun(traumaKey);
        }

        public async ValueTask StartTraumaRun(string traumaKey)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 1);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(StartTrauma)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = StartTraumaImpl(traumaKey);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task StopTrauma(string traumaKey)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return StopTraumaRunMaster(traumaKey).AsTask();
                else
                    return StopTraumaRun(traumaKey).AsTask();
            else
                return SendFuncs.StopTrauma(traumaKey, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> StopTraumaCreateDeferredDelegate(string traumaKey) => () =>
        {
            return StopTrauma(traumaKey);
        }

        ;
        public async ValueTask StopTraumaRunMaster(string traumaKey)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(StopTraumaCreateDeferredDelegate(traumaKey), nameof(StopTrauma));
            }

            await StopTraumaRun(traumaKey);
        }

        public async ValueTask StopTraumaRun(string traumaKey)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 2);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(StopTrauma)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = StopTraumaImpl(traumaKey);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task StartTrauma(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return StartTraumaRunMaster(traumaKey, traumaGiver).AsTask();
                else
                    return StartTraumaRun(traumaKey, traumaGiver).AsTask();
            else
                return SendFuncs.StartTrauma(traumaKey, traumaGiver, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> StartTraumaCreateDeferredDelegate(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver) => () =>
        {
            return StartTrauma(traumaKey, traumaGiver);
        }

        ;
        public async ValueTask StartTraumaRunMaster(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(StartTraumaCreateDeferredDelegate(traumaKey, traumaGiver), nameof(StartTrauma));
            }

            await StartTraumaRun(traumaKey, traumaGiver);
        }

        public async ValueTask StartTraumaRun(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 3);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(StartTrauma)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = StartTraumaImpl(traumaKey, traumaGiver);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task StopTrauma(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return StopTraumaRunMaster(traumaKey, traumaGiver).AsTask();
                else
                    return StopTraumaRun(traumaKey, traumaGiver).AsTask();
            else
                return SendFuncs.StopTrauma(traumaKey, traumaGiver, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> StopTraumaCreateDeferredDelegate(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver) => () =>
        {
            return StopTrauma(traumaKey, traumaGiver);
        }

        ;
        public async ValueTask StopTraumaRunMaster(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(StopTraumaCreateDeferredDelegate(traumaKey, traumaGiver), nameof(StopTrauma));
            }

            await StopTraumaRun(traumaKey, traumaGiver);
        }

        public async ValueTask StopTraumaRun(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 4);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(StopTrauma)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = StopTraumaImpl(traumaKey, traumaGiver);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task SuspendTrauma(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SuspendTraumaRunMaster(traumaKey, traumaGiver).AsTask();
                else
                    return SuspendTraumaRun(traumaKey, traumaGiver).AsTask();
            else
                return SendFuncs.SuspendTrauma(traumaKey, traumaGiver, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SuspendTraumaCreateDeferredDelegate(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver) => () =>
        {
            return SuspendTrauma(traumaKey, traumaGiver);
        }

        ;
        public async ValueTask SuspendTraumaRunMaster(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SuspendTraumaCreateDeferredDelegate(traumaKey, traumaGiver), nameof(SuspendTrauma));
            }

            await SuspendTraumaRun(traumaKey, traumaGiver);
        }

        public async ValueTask SuspendTraumaRun(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 5);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(SuspendTrauma)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = SuspendTraumaImpl(traumaKey, traumaGiver);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public ValueTask<bool> RemoveTrauma(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return RemoveTraumaRunMaster(traumaKey, traumaGiver);
                else
                    return RemoveTraumaRun(traumaKey, traumaGiver);
            else
                return SendFuncs.RemoveTrauma(traumaKey, traumaGiver, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId());
        }

        private Func<Task<bool>> RemoveTraumaCreateDeferredDelegate(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver) => () =>
        {
            return RemoveTrauma(traumaKey, traumaGiver).AsTask();
        }

        ;
        public async ValueTask<bool> RemoveTraumaRunMaster(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(RemoveTraumaCreateDeferredDelegate(traumaKey, traumaGiver), nameof(RemoveTrauma));
            }

            return await RemoveTraumaRun(traumaKey, traumaGiver);
        }

        public async ValueTask<bool> RemoveTraumaRun(string traumaKey, Src.Aspects.Impl.Stats.ITraumaGiver traumaGiver)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 6);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(RemoveTrauma)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = RemoveTraumaImpl(traumaKey, traumaGiver);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            return await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                    else
                        return returnTask.Result;
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public ValueTask<bool> HasActiveTraumas(string[] traumas)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.NeedDeferredRpcOnMigrating())
                return HasActiveTraumasRunMaster(traumas);
            else
                return HasActiveTraumasRun(traumas);
        }

        private Func<Task<bool>> HasActiveTraumasCreateDeferredDelegate(string[] traumas) => () =>
        {
            return HasActiveTraumas(traumas).AsTask();
        }

        ;
        public async ValueTask<bool> HasActiveTraumasRunMaster(string[] traumas)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(HasActiveTraumasCreateDeferredDelegate(traumas), nameof(HasActiveTraumas));
            }

            return await HasActiveTraumasRun(traumas);
        }

        public async ValueTask<bool> HasActiveTraumasRun(string[] traumas)
        {
            this.CheckValidateEntityInAsyncContext();
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 7);
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                try
                {
                    return await HasActiveTraumasImpl(traumas);
                }
                finally
                {
                    ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public Task<bool> RecalculateTraumas()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return RecalculateTraumasRunMaster().AsTask();
                else
                    return RecalculateTraumasRun().AsTask();
            else
                return SendFuncs.RecalculateTraumas(this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task<bool>> RecalculateTraumasCreateDeferredDelegate() => () =>
        {
            return RecalculateTraumas();
        }

        ;
        public async ValueTask<bool> RecalculateTraumasRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(RecalculateTraumasCreateDeferredDelegate(), nameof(RecalculateTraumas));
            }

            return await RecalculateTraumasRun();
        }

        public async ValueTask<bool> RecalculateTraumasRun()
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ITraumas), 8);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(RecalculateTraumas)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = RecalculateTraumasImpl();
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            return await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                    else
                        return returnTask.Result;
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }
    }
}

namespace GeneratedCode.DeltaObjects
{
    public partial class OwnerInformation
    {
        public Task SetOwner(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> owner)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetOwnerRunMaster(owner).AsTask();
                else
                    return SetOwnerRun(owner).AsTask();
            else
                return SendFuncs.SetOwner(owner, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetOwnerCreateDeferredDelegate(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> owner) => () =>
        {
            return SetOwner(owner);
        }

        ;
        public async ValueTask SetOwnerRunMaster(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> owner)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetOwnerCreateDeferredDelegate(owner), nameof(SetOwner));
            }

            await SetOwnerRun(owner);
        }

        public async ValueTask SetOwnerRun(SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity> owner)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.IOwnerInformation), 0);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(SetOwner)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = SetOwnerImpl(owner);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }

        public Task SetLockPredicate(ResourceSystem.Aspects.AccessRights.AccessPredicateDef accessPredicate)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.IsMaster())
                if (this.NeedDeferredRpcOnMigrating())
                    return SetLockPredicateRunMaster(accessPredicate).AsTask();
                else
                    return SetLockPredicateRun(accessPredicate).AsTask();
            else
                return SendFuncs.SetLockPredicate(accessPredicate, this, this.GetNetworkProxyForSerialization(), this.EntitiesRepository, GetActualMigratingId()).AsTask();
        }

        private Func<Task> SetLockPredicateCreateDeferredDelegate(ResourceSystem.Aspects.AccessRights.AccessPredicateDef accessPredicate) => () =>
        {
            return SetLockPredicate(accessPredicate);
        }

        ;
        public async ValueTask SetLockPredicateRunMaster(ResourceSystem.Aspects.AccessRights.AccessPredicateDef accessPredicate)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetLockPredicateCreateDeferredDelegate(accessPredicate), nameof(SetLockPredicate));
            }

            await SetLockPredicateRun(accessPredicate);
        }

        public async ValueTask SetLockPredicateRun(ResourceSystem.Aspects.AccessRights.AccessPredicateDef accessPredicate)
        {
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.IOwnerInformation), 1);
            var getTask = this.GetThisExclusive();
            var wrapper = getTask.IsCompleted ? getTask.Result : await getTask;
            using (wrapper)
            {
                if (wrapper == null && EntitiesRepository != null)
                    throw new Exception($"{nameof(SetLockPredicate)} GetExclusive wrapper is null");
                GeneratedCode.Manual.Repositories.RpcCurrentObject.ThisObj = this;
                Guid __oldMigrationId__ = default;
                var __needSetMigrationgId__ = MigratingId != Guid.Empty;
                if (__needSetMigrationgId__)
                {
                    __oldMigrationId__ = GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                    GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
                }

                try
                {
                    var returnTask = SetLockPredicateImpl(accessPredicate);
                    if (!returnTask.IsCompleted || returnTask.IsFaulted)
                    {
                        var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                        try
                        {
                            await returnTask;
                        }
                        finally
                        {
                            ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                        }
                    }
                }
                finally
                {
                    if (__needSetMigrationgId__)
                        GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
                }
            }
        }
    }
}

namespace GeneratedCode.DeltaObjects
{
    public partial class LocomotionOwner
    {
        public ValueTask<bool> IsValid()
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.NeedDeferredRpcOnMigrating())
                return IsValidRunMaster();
            else
                return IsValidRun();
        }

        private Func<Task<bool>> IsValidCreateDeferredDelegate() => () =>
        {
            return IsValid().AsTask();
        }

        ;
        public async ValueTask<bool> IsValidRunMaster()
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    return await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(IsValidCreateDeferredDelegate(), nameof(IsValid));
            }

            return await IsValidRun();
        }

        public async ValueTask<bool> IsValidRun()
        {
            this.CheckValidateEntityInAsyncContext();
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ILocomotionOwner), 0);
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                try
                {
                    return await IsValidImpl();
                }
                finally
                {
                    ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }

        public ValueTask SetLocomotion(SharedCode.Entities.Engine.ILocomotionEngineAgent locomotion, SharedCode.Entities.Engine.IDirectMotionProducer directMotionProducer, SharedCode.Entities.Engine.IGuideProvider guideProvider)
        {
            this.CheckValidateEntityInAsyncContext();
            if (this.NeedDeferredRpcOnMigrating())
                return SetLocomotionRunMaster(locomotion, directMotionProducer, guideProvider);
            else
                return SetLocomotionRun(locomotion, directMotionProducer, guideProvider);
        }

        private Func<Task> SetLocomotionCreateDeferredDelegate(SharedCode.Entities.Engine.ILocomotionEngineAgent locomotion, SharedCode.Entities.Engine.IDirectMotionProducer directMotionProducer, SharedCode.Entities.Engine.IGuideProvider guideProvider) => () =>
        {
            return SetLocomotion(locomotion, directMotionProducer, guideProvider).AsTask();
        }

        ;
        public async ValueTask SetLocomotionRunMaster(SharedCode.Entities.Engine.ILocomotionEngineAgent locomotion, SharedCode.Entities.Engine.IDirectMotionProducer directMotionProducer, SharedCode.Entities.Engine.IGuideProvider guideProvider)
        {
            if (parentEntity != null)
            {
                var __checkTask__ = ((IEntityExt)parentEntity).NeedPutToDeferredRpcQueue();
                if (!__checkTask__.IsCompleted)
                    await __checkTask__;
                if (__checkTask__.Result)
                    await ((IEntityExt)parentEntity).AddDeferredMigratingRpc(SetLocomotionCreateDeferredDelegate(locomotion, directMotionProducer, guideProvider), nameof(SetLocomotion));
            }

            await SetLocomotionRun(locomotion, directMotionProducer, guideProvider);
        }

        public async ValueTask SetLocomotionRun(SharedCode.Entities.Engine.ILocomotionEngineAgent locomotion, SharedCode.Entities.Engine.IDirectMotionProducer directMotionProducer, SharedCode.Entities.Engine.IGuideProvider guideProvider)
        {
            this.CheckValidateEntityInAsyncContext();
            GeneratedCode.Network.Statistic.Statistics<GeneratedCode.Network.Statistic.RpcInnerStatistics>.Instance.Used(typeof(SharedCode.Entities.ILocomotionOwner), 1);
            Guid __oldMigrationId__ = default;
            var __needSetMigrationgId__ = MigratingId != Guid.Empty;
            if (__needSetMigrationgId__)
            {
                __oldMigrationId__ = global::GeneratedCode.Manual.Repositories.MigrationIdHolder.CurrentMigrationId;
                global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref MigratingId);
            }

            try
            {
                var __needDecrement__ = IncrementExecutedMethodsCounter(out var __parentEntity__);
                try
                {
                    await SetLocomotionImpl(locomotion, directMotionProducer, guideProvider);
                }
                finally
                {
                    ((IEntityExt)__parentEntity__)?.DecrementExecutedMethodsCounter(__needDecrement__);
                }
            }
            finally
            {
                if (__needSetMigrationgId__)
                    global::GeneratedCode.Manual.Repositories.MigrationIdHolder.SetCurrentMigrationId(ref __oldMigrationId__);
            }
        }
    }
}