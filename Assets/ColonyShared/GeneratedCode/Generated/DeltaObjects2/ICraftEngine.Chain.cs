// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using SharedCode.Entities.Service;
using SharedCode.EntitySystem.ChainCalls;
using SharedCode.Logging;
using SharedCode.OurSimpleIoC;
using SharedCode.Utils;
using System.Linq;
using System.Collections.Generic;
using System.CodeDom.Compiler;

namespace GeneratedCode.DeltaObjects.Chain
{
    [GeneratedCode("CodeGen", "1.0")]
    public class CraftEngineChainProxy : BaseChainEntity
    {
        public CraftEngineChainProxy(SharedCode.Entities.Engine.ICraftEngine entity): base(entity)
        {
        }

        public CraftEngineChainProxy(SharedCode.Entities.Engine.ICraftEngine entity, IChainedEntity fromChain): base(entity, fromChain)
        {
        }

        public CraftEngineChainProxy SetResultContainerAddress(ChainArgument<SharedCode.EntitySystem.PropertyAddress> resultContainerAddress)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (resultContainerAddress is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)resultContainerAddress).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)resultContainerAddress);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 0, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy UpdateFuelTime()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 1, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy UpdateCraftingTime()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 2, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy UpdateRepairTime(ChainArgument<SharedCode.EntitySystem.PropertyAddress> itemAddress, ChainArgument<int> itemIndex)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (itemAddress is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)itemAddress).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)itemAddress);
                if (itemIndex is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)itemIndex).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)itemIndex);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 3, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy CanRun()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 4, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy RunCraft()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 5, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy StopCraft()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 6, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy Craft(ChainArgument<Assets.ColonyShared.SharedCode.Aspects.Craft.CraftRecipeDef> recipe, ChainArgument<int> variantIdx, ChainArgument<int> count, ChainArgument<int[]> mandatorySlotPermutation, ChainArgument<int[]> optionalSlotPermutation, ChainArgument<SharedCode.EntitySystem.PropertyAddress> inventoryAddress, ChainArgument<SharedCode.EntitySystem.PropertyAddress> inventoryAddress2)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (recipe is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)recipe).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.ColonyShared.SharedCode.Aspects.Craft.CraftRecipeDef)recipe);
                if (variantIdx is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)variantIdx).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)variantIdx);
                if (count is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)count).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)count);
                if (mandatorySlotPermutation is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)mandatorySlotPermutation).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int[])mandatorySlotPermutation);
                if (optionalSlotPermutation is IChainResult)
                    argumetRefs.Add(4, ((IChainResult)optionalSlotPermutation).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int[])optionalSlotPermutation);
                if (inventoryAddress is IChainResult)
                    argumetRefs.Add(5, ((IChainResult)inventoryAddress).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)inventoryAddress);
                if (inventoryAddress2 is IChainResult)
                    argumetRefs.Add(6, ((IChainResult)inventoryAddress2).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)inventoryAddress2);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 7, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy Repair(ChainArgument<SharedCode.EntitySystem.PropertyAddress> itemAddress, ChainArgument<int> itemIndex, ChainArgument<int> recipeIndex, ChainArgument<int> variantIdx, ChainArgument<int[]> mandatorySlotPermutation, ChainArgument<int[]> optionalSlotPermutation, ChainArgument<SharedCode.EntitySystem.PropertyAddress> fromInventoryAddress, ChainArgument<SharedCode.EntitySystem.PropertyAddress> fromInventoryAddress2)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (itemAddress is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)itemAddress).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)itemAddress);
                if (itemIndex is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)itemIndex).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)itemIndex);
                if (recipeIndex is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)recipeIndex).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)recipeIndex);
                if (variantIdx is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)variantIdx).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)variantIdx);
                if (mandatorySlotPermutation is IChainResult)
                    argumetRefs.Add(4, ((IChainResult)mandatorySlotPermutation).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int[])mandatorySlotPermutation);
                if (optionalSlotPermutation is IChainResult)
                    argumetRefs.Add(5, ((IChainResult)optionalSlotPermutation).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int[])optionalSlotPermutation);
                if (fromInventoryAddress is IChainResult)
                    argumetRefs.Add(6, ((IChainResult)fromInventoryAddress).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)fromInventoryAddress);
                if (fromInventoryAddress2 is IChainResult)
                    argumetRefs.Add(7, ((IChainResult)fromInventoryAddress2).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)fromInventoryAddress2);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 8, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy RemoveCraft(ChainArgument<int> recipeIndex)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (recipeIndex is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)recipeIndex).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)recipeIndex);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 9, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy SwapCraft(ChainArgument<int> index1, ChainArgument<int> index2)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (index1 is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)index1).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)index1);
                if (index2 is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)index2).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)index2);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 10, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy StopCraftWithWorkbench(ChainArgument<SharedCode.Aspects.Item.Templates.WorkbenchTypeDef> workbenchType)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (workbenchType is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)workbenchType).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Item.Templates.WorkbenchTypeDef)workbenchType);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 11, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy ContinueCraftWithWorkbench(ChainArgument<SharedCode.Aspects.Item.Templates.WorkbenchTypeDef> workbenchType)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (workbenchType is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)workbenchType).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Item.Templates.WorkbenchTypeDef)workbenchType);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 12, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public CraftEngineChainProxy Delay(float duration, bool repeat = false, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, repeat ? -1 : 0, fromUtcNow));
            return this;
        }

        public CraftEngineChainProxy DelayCount(float duration, int count, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, count, fromUtcNow));
            return this;
        }

        public CraftEngineChainProxy StoreResult(string name)
        {
            ((ChainBlockCall)chainBatch.Chain.Last()).SetStoreResultKey(name);
            return this;
        }
    }

    public static partial class ChainProxyExtensions
    {
        public static CraftEngineChainProxy Chain(this SharedCode.Entities.Engine.ICraftEngine entity)
        {
            return new CraftEngineChainProxy(entity);
        }

        public static CraftEngineChainProxy ContinueChain(this SharedCode.Entities.Engine.ICraftEngine entity, IChainedEntity fromChain)
        {
            return new CraftEngineChainProxy(entity, fromChain);
        }
    }
}