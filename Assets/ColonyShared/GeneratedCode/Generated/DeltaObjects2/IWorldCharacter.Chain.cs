// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using SharedCode.Entities.Service;
using SharedCode.EntitySystem.ChainCalls;
using SharedCode.Logging;
using SharedCode.OurSimpleIoC;
using SharedCode.Utils;
using System.Linq;
using System.Collections.Generic;
using System.CodeDom.Compiler;

namespace GeneratedCode.DeltaObjects.Chain
{
    [GeneratedCode("CodeGen", "1.0")]
    public class WorldCharacterChainProxy : BaseChainEntity
    {
        public WorldCharacterChainProxy(SharedCode.Entities.IWorldCharacter entity): base(entity)
        {
        }

        public WorldCharacterChainProxy(SharedCode.Entities.IWorldCharacter entity, IChainedEntity fromChain): base(entity, fromChain)
        {
        }

        public WorldCharacterChainProxy InvokeNewChatMessageEvent(ChainArgument<string> name, ChainArgument<string> message)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (name is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)name).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)name);
                if (message is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)message).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)message);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 0, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy SendChatMessage(ChainArgument<string> message)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (message is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)message).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)message);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 1, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy Respawn(ChainArgument<bool> onBaken, ChainArgument<bool> anyCommonBaken, ChainArgument<System.Guid> commonBakenId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (onBaken is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)onBaken).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)onBaken);
                if (anyCommonBaken is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)anyCommonBaken).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (bool)anyCommonBaken);
                if (commonBakenId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)commonBakenId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)commonBakenId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 2, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy HasBaken()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 3, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy IsBakenActivated(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> bakenRef)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (bakenRef is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)bakenRef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)bakenRef);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 4, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy ActivateCommonBaken(ChainArgument<System.Guid> commonBakenGuid)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (commonBakenGuid is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)commonBakenGuid).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)commonBakenGuid);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 5, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy InvokeItemDropped(ChainArgument<SharedCode.Aspects.Item.Templates.BaseItemResource> item, ChainArgument<int> count)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (item is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)item).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Item.Templates.BaseItemResource)item);
                if (count is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)count).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)count);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 6, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy AddItems(ChainArgument<System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack>> itemResourcesToAdd, ChainArgument<SharedCode.EntitySystem.PropertyAddress> destination)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (itemResourcesToAdd is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)itemResourcesToAdd).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack>)itemResourcesToAdd);
                if (destination is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)destination).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)destination);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 7, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy MoveItem(ChainArgument<SharedCode.EntitySystem.PropertyAddress> source, ChainArgument<int> sourceSlotId, ChainArgument<SharedCode.EntitySystem.PropertyAddress> destination, ChainArgument<int> destinationSlotId, ChainArgument<int> count, ChainArgument<System.Guid> clientSrcEntityId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (source is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                if (sourceSlotId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)sourceSlotId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)sourceSlotId);
                if (destination is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)destination).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)destination);
                if (destinationSlotId is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)destinationSlotId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)destinationSlotId);
                if (count is IChainResult)
                    argumetRefs.Add(4, ((IChainResult)count).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)count);
                if (clientSrcEntityId is IChainResult)
                    argumetRefs.Add(5, ((IChainResult)clientSrcEntityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)clientSrcEntityId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 8, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy MoveAllItems(ChainArgument<SharedCode.EntitySystem.PropertyAddress> source, ChainArgument<SharedCode.EntitySystem.PropertyAddress> destination)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (source is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                if (destination is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)destination).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)destination);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 9, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy RemoveItem(ChainArgument<SharedCode.EntitySystem.PropertyAddress> source, ChainArgument<int> sourceSlotId, ChainArgument<int> count, ChainArgument<System.Guid> clientEntityId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (source is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                if (sourceSlotId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)sourceSlotId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)sourceSlotId);
                if (count is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)count).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)count);
                if (clientEntityId is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)clientEntityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)clientEntityId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 10, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy SavePerk(ChainArgument<SharedCode.EntitySystem.PropertyAddress> source, ChainArgument<int> sourceSlotId, ChainArgument<System.Guid> clientSrcEntityId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (source is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                if (sourceSlotId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)sourceSlotId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)sourceSlotId);
                if (clientSrcEntityId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)clientSrcEntityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)clientSrcEntityId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 11, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy DisassemblyPerk(ChainArgument<SharedCode.EntitySystem.PropertyAddress> source, ChainArgument<int> sourceSlotId, ChainArgument<System.Guid> clientSrcEntityId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (source is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                if (sourceSlotId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)sourceSlotId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)sourceSlotId);
                if (clientSrcEntityId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)clientSrcEntityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)clientSrcEntityId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 12, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy Break(ChainArgument<SharedCode.EntitySystem.PropertyAddress> source, ChainArgument<int> sourceSlotId, ChainArgument<System.Guid> clientSrcEntityId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (source is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                if (sourceSlotId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)sourceSlotId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)sourceSlotId);
                if (clientSrcEntityId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)clientSrcEntityId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)clientSrcEntityId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 13, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy AddPerkSlot(ChainArgument<SharedCode.EntitySystem.PropertyAddress> source, ChainArgument<int> slotId, ChainArgument<SharedCode.Aspects.Item.Templates.ItemTypeResource> perkSlotType)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (source is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)source).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.PropertyAddress)source);
                if (slotId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)slotId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)slotId);
                if (perkSlotType is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)perkSlotType).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Item.Templates.ItemTypeResource)perkSlotType);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 14, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy CanAddPerkSlot(ChainArgument<SharedCode.Aspects.Item.Templates.ItemTypeResource> perkSlotType)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (perkSlotType is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)perkSlotType).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Item.Templates.ItemTypeResource)perkSlotType);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 15, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy AddUsedSlot(ChainArgument<Assets.Src.ResourcesSystem.Base.ResourceIDFull> dollSlotRes)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (dollSlotRes is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)dollSlotRes).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.Src.ResourcesSystem.Base.ResourceIDFull)dollSlotRes);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 16, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy RemoveUsedSlot(ChainArgument<Assets.Src.ResourcesSystem.Base.ResourceIDFull> dollSlotRes)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (dollSlotRes is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)dollSlotRes).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.Src.ResourcesSystem.Base.ResourceIDFull)dollSlotRes);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 17, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy DropCorpse()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 18, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy CreateBuildElement(ChainArgument<SharedCode.DeltaObjects.Building.BuildType> type, ChainArgument<System.Guid> placeId, ChainArgument<SharedCode.Aspects.Building.BuildRecipeDef> buildRecipeDef, ChainArgument<SharedCode.Aspects.Building.CreateBuildElementData> data)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (type is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)type).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.DeltaObjects.Building.BuildType)type);
                if (placeId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)placeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)placeId);
                if (buildRecipeDef is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)buildRecipeDef).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Building.BuildRecipeDef)buildRecipeDef);
                if (data is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)data).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Building.CreateBuildElementData)data);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 19, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy OperateBuildElement(ChainArgument<SharedCode.DeltaObjects.Building.BuildType> type, ChainArgument<System.Guid> placeId, ChainArgument<System.Guid> elementId, ChainArgument<SharedCode.Entities.Building.OperationData> data)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (type is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)type).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.DeltaObjects.Building.BuildType)type);
                if (placeId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)placeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)placeId);
                if (elementId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)elementId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)elementId);
                if (data is IChainResult)
                    argumetRefs.Add(3, ((IChainResult)data).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.Building.OperationData)data);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 20, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy SetBuildCheat(ChainArgument<SharedCode.Entities.Building.OperationData> data)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (data is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)data).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.Building.OperationData)data);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 21, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy GetBuildCheat(ChainArgument<SharedCode.Entities.Building.OperationData> data)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (data is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)data).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.Building.OperationData)data);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 22, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy AddPointMarker(ChainArgument<System.Guid> pointMarkerGuid, ChainArgument<Assets.ColonyShared.SharedCode.Aspects.WorldObjects.PointMarker> pointMarker)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (pointMarkerGuid is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)pointMarkerGuid).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)pointMarkerGuid);
                if (pointMarker is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)pointMarker).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.ColonyShared.SharedCode.Aspects.WorldObjects.PointMarker)pointMarker);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 23, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy RemovePointMarker(ChainArgument<System.Guid> pointMarkerGuid)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (pointMarkerGuid is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)pointMarkerGuid).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)pointMarkerGuid);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 24, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy AddPointOfInterest(ChainArgument<Assets.ColonyShared.SharedCode.Aspects.WorldObjects.PointOfInterestDef> poi)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (poi is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)poi).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.ColonyShared.SharedCode.Aspects.WorldObjects.PointOfInterestDef)poi);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 25, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy RemovePointOfInterest(ChainArgument<Assets.ColonyShared.SharedCode.Aspects.WorldObjects.PointOfInterestDef> poi)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (poi is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)poi).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.ColonyShared.SharedCode.Aspects.WorldObjects.PointOfInterestDef)poi);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 26, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy NotifyThatClientIsGone()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 27, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy NotifyThatClientIsBack()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 28, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy AFKStateMachineChainCall()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 29, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy OnBeforeResurrectEvent(ChainArgument<System.Guid> id, ChainArgument<int> typeId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (id is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)id).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)id);
                if (typeId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)typeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)typeId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 30, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy UnstuckTeleport(ChainArgument<float> minTimeout)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (minTimeout is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)minTimeout).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)minTimeout);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 31, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy UnstuckTeleportDo()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 32, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy TestCheatRpc(ChainArgument<string> argument)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (argument is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)argument).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)argument);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 33, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy Suicide()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 34, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy SuicideCheat()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 35, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy ResyncAccountExperience()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 36, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy NameSet(ChainArgument<string> value)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (value is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)value).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)value);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 37, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy PrefabSet(ChainArgument<string> value)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (value is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)value).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (string)value);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 38, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy ChangeCurrencies(ChainArgument<System.Collections.Generic.List<SharedCode.Entities.CurrencyResourcePack>> currencies)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (currencies is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)currencies).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Collections.Generic.List<SharedCode.Entities.CurrencyResourcePack>)currencies);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 39, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy GetCurrencyValue(ChainArgument<SharedCode.Aspects.Science.CurrencyResource> currency)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (currency is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)currency).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Aspects.Science.CurrencyResource)currency);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 40, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy ChangeStatistic(ChainArgument<Assets.ColonyShared.SharedCode.Aspects.Statictic.StatisticType> statistic, ChainArgument<Assets.ColonyShared.SharedCode.Aspects.Statictic.StatisticType> target, ChainArgument<float> value)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (statistic is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)statistic).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.ColonyShared.SharedCode.Aspects.Statictic.StatisticType)statistic);
                if (target is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)target).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.ColonyShared.SharedCode.Aspects.Statictic.StatisticType)target);
                if (value is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)value).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)value);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 41, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy SetStat(ChainArgument<Assets.Src.Aspects.Impl.Stats.StatResource> res, ChainArgument<float> setValue)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (res is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)res).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.Src.Aspects.Impl.Stats.StatResource)res);
                if (setValue is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)setValue).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)setValue);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 42, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy AllowedSpawnPointSet(ChainArgument<SharedCode.Entities.GameObjectEntities.SpawnPointTypeDef> value)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (value is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)value).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.Entities.GameObjectEntities.SpawnPointTypeDef)value);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 43, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy ReceiveDamageInternal(ChainArgument<Assets.ColonyShared.SharedCode.Aspects.Damage.Damage> incomingDamage, ChainArgument<System.Guid> attackerId, ChainArgument<int> attackerTypeId)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (incomingDamage is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)incomingDamage).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (Assets.ColonyShared.SharedCode.Aspects.Damage.Damage)incomingDamage);
                if (attackerId is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)attackerId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Guid)attackerId);
                if (attackerTypeId is IChainResult)
                    argumetRefs.Add(2, ((IChainResult)attackerTypeId).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (int)attackerTypeId);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 44, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy ChangeHealthInternal(ChainArgument<float> health)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (health is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)health).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (float)health);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 45, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy SetGender(ChainArgument<ResourceSystem.Aspects.Misc.GenderDef> gender)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (gender is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)gender).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (ResourceSystem.Aspects.Misc.GenderDef)gender);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 46, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy GatherResources(ChainArgument<SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>> giver, ChainArgument<System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack>> items)
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                var serializer = ServicesPool.Services.Get<SharedCode.Serializers.ISerializer>();
                if (giver is IChainResult)
                    argumetRefs.Add(0, ((IChainResult)giver).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (SharedCode.EntitySystem.OuterRef<SharedCode.EntitySystem.IEntity>)giver);
                if (items is IChainResult)
                    argumetRefs.Add(1, ((IChainResult)items).Key);
                else
                    __buffer__ = serializer.Serialize(__buffer__, ref offset, (System.Collections.Generic.List<SharedCode.Entities.ItemResourcePack>)items);
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 47, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy GetIncomingDamageMultiplier()
        {
            var argumetRefs = new Dictionary<int, string>();
            var __id__ = SharedCode.EntitySystem.EntityPropertyResolvers.EntityPropertyResolver.GetPropertyAddress(__entity__);
            int offset = 0;
            var __buffer__ = EntitySystem.RpcHelper.BufferPool.Take();
            try
            {
                byte[] buffer = new byte[offset];
                Buffer.BlockCopy(__buffer__, 0, buffer, 0, offset);
                var __newBlock__ = new ChainBlockCall(__id__, 48, buffer, argumetRefs);
                validateCallBlock(__newBlock__);
                chainBatch.Chain.Add(__newBlock__);
            }
            finally
            {
                EntitySystem.RpcHelper.BufferPool.Return(__buffer__);
            }

            return this;
        }

        public WorldCharacterChainProxy Delay(float duration, bool repeat = false, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, repeat ? -1 : 0, fromUtcNow));
            return this;
        }

        public WorldCharacterChainProxy DelayCount(float duration, int count, bool fromUtcNow = true)
        {
            chainBatch.Chain.Add(new ChainBlockPeriod(duration, count, fromUtcNow));
            return this;
        }

        public WorldCharacterChainProxy StoreResult(string name)
        {
            ((ChainBlockCall)chainBatch.Chain.Last()).SetStoreResultKey(name);
            return this;
        }
    }

    public static partial class ChainProxyExtensions
    {
        public static WorldCharacterChainProxy Chain(this SharedCode.Entities.IWorldCharacter entity)
        {
            return new WorldCharacterChainProxy(entity);
        }

        public static WorldCharacterChainProxy ContinueChain(this SharedCode.Entities.IWorldCharacter entity, IChainedEntity fromChain)
        {
            return new WorldCharacterChainProxy(entity, fromChain);
        }
    }
}